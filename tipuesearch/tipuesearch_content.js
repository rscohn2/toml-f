var tipuesearch = {"pages":[{"title":" TOML-Fortran ","text":"TOML-Fortran A TOML parser implementation for data serialization and deserialization in Fortran. the TOML standard currently supported TOML v1.0.0-rc2 specification the TOML-Fortran project Getting Started Meson Create a new meson project and include toml-f either as git-submodule in your subprojects directory or create a wrap file to fetch it from upstream: [wrap-git] directory = toml-f url = https://github.com/toml-f/toml-f revision = head To load the project the necessary boilerplate code for subprojects is just tomlf_prj = subproject ( 'toml-f' , version : '>=0.2' , default_options : [ 'default_library=static' , ], ) tomlf_dep = tomlf_prj . get_variable ( 'tomlf_dep' ) Now you can add tomlf_dep to your dependencies and access the public API by the tomlf module. We recommend to set the default library type of toml-f to static when linking your applications or library against it.\nNote for library type both and shared toml-f will install itself along with your project. For more fine-tuned control you can access: the library target with tomlf_lib the private include dir of this target, containing the Fortran module files, with tomlf_inc the license files of toml-f with tomlf_lic If you are linking your application statically against toml-f and still want to distribute the license files of toml-f (thank you), just use install_data ( tomlf_prj . get_variable ( 'tomlf_lic' ), install_dir : get_option ( 'datadir' ) / 'licenses' / meson . project_name () / 'toml-f' , ) CMake Create a new CMake project and include toml-f as git-submodule in your subprojects directory with git submodule add https://github.com/toml-f/toml-f subprojects/toml-f To include the project the necessary boilerplate code for subprojects is just # subprojects/CMakeLists.txt set ( BUILD_SHARED_LIBS OFF ) add_subdirectory ( \"toml-f\" ) list ( APPEND lib-deps \"toml-f-lib\" ) set ( lib-deps \"${lib-deps}\" PARENT_SCOPE ) Now you can add toml-f-lib to your dependencies and access the public API by the tomlf module. We recommend to disable building toml-f as shared library and just link your applications or library statically against it.\nThe toml-f subproject will decide based on the library type if it should install itself along with your project. Fortran Package Manager (fpm) TOML-Fortran supports fpm as build system as well.\nJust add toml-f to the dependencies in your fpm.toml file: [dependencies] [dependencies.toml-f] git = \"https://github.com/toml-f/toml-f\" For a usage example of toml-f you can look-up the example in the TOML-Fortran repository ( example-1 ) or just checkout fpm itself, which is using toml-f . Developer Info Sebastian Ehlert","tags":"home","loc":"index.html"},{"title":"tomlf.f90 – TOML-Fortran","text":"Contents Modules tomlf Source Code tomlf.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Minimal public API for TOML-Fortran module tomlf use tomlf_build , only : get_value , set_value use tomlf_de , only : toml_parse use tomlf_error , only : toml_error , toml_stat use tomlf_ser , only : toml_serializer use tomlf_type , only : toml_table , toml_array , toml_key , is_array_of_tables , & & new_table , add_table , add_array , len use tomlf_version , only : tomlf_version_string , tomlf_version_compact , & & get_tomlf_version implicit none public end module tomlf","tags":"","loc":"sourcefile/tomlf.f90.html"},{"title":"datetime.f90 – TOML-Fortran","text":"Contents Modules tomlf_datetime Source Code datetime.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a TOML datetime value module tomlf_datetime use tomlf_constants , only : tfc implicit none private public :: toml_datetime , toml_time , toml_date !> TOML time value (HH:MM:SS.sssssZ...) type :: toml_time integer :: hour = 0 integer :: minute = 0 integer :: second = 0 integer , allocatable :: millisec character ( len = :), allocatable :: zone contains generic :: assignment ( = ) => to_string procedure , pass ( rhs ) :: to_string => time_to_string end type !> TOML date value (YYYY-MM-DD) type :: toml_date integer :: year = 0 integer :: month = 0 integer :: day = 0 contains generic :: assignment ( = ) => to_string procedure , pass ( rhs ) :: to_string => date_to_string end type !> TOML datatime value type type :: toml_datetime type ( toml_date ), allocatable :: date type ( toml_time ), allocatable :: time contains generic :: assignment ( = ) => to_string procedure , pass ( rhs ) :: to_string => datetime_to_string end type contains subroutine date_to_string ( lhs , rhs ) character ( kind = tfc , len = :), allocatable , intent ( out ) :: lhs class ( toml_date ), intent ( in ) :: rhs allocate ( character ( kind = tfc , len = 10 ) :: lhs ) write ( lhs , '(i4.4,\"-\",i2.2,\"-\",i2.2)' ) & & rhs % year , rhs % month , rhs % day end subroutine date_to_string subroutine time_to_string ( lhs , rhs ) character ( kind = tfc , len = :), allocatable , intent ( out ) :: lhs class ( toml_time ), intent ( in ) :: rhs if ( allocated ( rhs % millisec )) then allocate ( character ( kind = tfc , len = 12 ) :: lhs ) write ( lhs , '(i2.2,\":\",i2.2,\":\",i2.2,\".\",i3.3)' ) & & rhs % hour , rhs % minute , rhs % second , rhs % millisec else allocate ( character ( kind = tfc , len = 8 ) :: lhs ) write ( lhs , '(i2.2,\":\",i2.2,\":\",i2.2)' ) & & rhs % hour , rhs % minute , rhs % second end if if ( allocated ( rhs % zone )) lhs = lhs // trim ( rhs % zone ) end subroutine time_to_string subroutine datetime_to_string ( lhs , rhs ) character ( kind = tfc , len = :), allocatable , intent ( out ) :: lhs class ( toml_datetime ), intent ( in ) :: rhs character ( kind = tfc , len = :), allocatable :: temporary if ( allocated ( rhs % date )) then call rhs % date % to_string ( lhs ) if ( allocated ( rhs % time )) then call rhs % time % to_string ( temporary ) lhs = lhs // tfc_ 'T' // temporary end if else if ( allocated ( rhs % time )) lhs = rhs % time end if end subroutine datetime_to_string end module tomlf_datetime","tags":"","loc":"sourcefile/datetime.f90.html"},{"title":"all.f90 – TOML-Fortran","text":"Contents Modules tomlf_all Source Code all.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Complete reexport of the public API of TOML-Fortran module tomlf_all use tomlf_build use tomlf_constants use tomlf_datetime use tomlf_de use tomlf_error use tomlf_ser use tomlf_structure use tomlf_type use tomlf_utils use tomlf_version implicit none public end module tomlf_all","tags":"","loc":"sourcefile/all.f90.html"},{"title":"constants.f90 – TOML-Fortran","text":"Contents Modules tomlf_constants Source Code constants.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module tomlf_constants use , intrinsic :: iso_fortran_env , only : output_unit implicit none private !> Single precision real numbers integer , public , parameter :: tf_sp = selected_real_kind ( 6 ) !> Double precision real numbers integer , public , parameter :: tf_dp = selected_real_kind ( 15 ) !> Char length for integers integer , public , parameter :: tf_i1 = selected_int_kind ( 2 ) !> Short length for integers integer , public , parameter :: tf_i2 = selected_int_kind ( 4 ) !> Length of default integers integer , public , parameter :: tf_i4 = selected_int_kind ( 9 ) !> Long length for integers integer , public , parameter :: tf_i8 = selected_int_kind ( 18 ) !> Default character kind integer , public , parameter :: tfc = selected_char_kind ( 'DEFAULT' ) !> Default float precision, IEEE 754 binary64 values expected integer , public , parameter :: tfr = tf_dp !> Default integer precision, 64 bit (signed long) range expected integer , public , parameter :: tfi = tf_i8 !> Default output channel integer , public , parameter :: tfout = output_unit !> Possible escape characters in TOML type :: enum_escape !> Backslash is used to escape other characters character ( kind = tfc , len = 1 ) :: backslash = tfc_ '\\' !> Double quotes signal strings with escape characters enabled character(kind=tfc, len=1) :: dquote = tfc_' \"' !> Single quotes signal strings without escape characters enabled character(kind=tfc, len=1) :: squote = tfc_'''' !> Newline character character(kind=tfc, len=1) :: newline = achar(10, kind=tfc) !> Formfeed character is allowed in strings character(kind=tfc, len=1) :: formfeed = achar(12, kind=tfc) !> Carriage return is allowed as part of the newline and in strings character(kind=tfc, len=1) :: carriage_return = achar(13, kind=tfc) !> Backspace is allowed in strings character(kind=tfc, len=1) :: bspace = achar(8, kind=tfc) !> Tabulators are allowed as whitespace and in strings character(kind=tfc, len=1) :: tabulator = achar(9, kind=tfc) end type enum_escape !> Actual enumerator with TOML escape characters type(enum_escape), public, parameter :: toml_escape = enum_escape() !> Possible kinds of TOML values in key-value pairs type :: enum_type !> Invalid type integer :: invalid = 100 !> String type integer :: string = 101 !> Boolean type integer :: boolean = 102 !> Integer type integer :: int = 103 !> Float type integer :: float = 104 !> Datetime type integer :: datetime = 105 end type enum_type !> Actual enumerator with TOML value types type(enum_type), public, parameter :: toml_type = enum_type() !> Single quotes denote literal strings character(kind=tfc, len=*), public, parameter :: TOML_SQUOTE = \" '\" !> Double quotes denote strings (with escape character possible) character(kind=tfc, len=*), public, parameter :: TOML_DQUOTE = ' \" ' character(kind=tfc, len=*), public, parameter :: TOML_NEWLINE = new_line(' a ') ! \\n character(kind=tfc, len=*), public, parameter :: TOML_TABULATOR = achar(9) ! \\t character(kind=tfc, len=*), public, parameter :: TOML_FORMFEED = achar(12) ! \\f character(kind=tfc, len=*), public, parameter :: TOML_CARRIAGE_RETURN = achar(13) ! \\r character(kind=tfc, len=*), public, parameter :: TOML_BACKSPACE = achar(8) ! \\b character(kind=tfc, len=*), public, parameter :: TOML_LOWERCASE = & & ' abcdefghijklmnopqrstuvwxyz ' character(kind=tfc, len=*), public, parameter :: TOML_UPPERCASE = & & ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' character(kind=tfc, len=*), public, parameter :: TOML_LETTERS = & & TOML_LOWERCASE//TOML_UPPERCASE !> Whitespace in TOML are blanks and tabs. character(kind=tfc, len=*), public, parameter :: TOML_WHITESPACE = & & ' '//toml_escape%tabulator character(kind=tfc, len=*), public, parameter :: TOML_DIGITS = ' 0123456789 ' character(kind=tfc, len=*), public, parameter :: TOML_BINDIGITS = & & ' 01 ' character(kind=tfc, len=*), public, parameter :: TOML_OCTDIGITS = & & ' 01234567 ' character(kind=tfc, len=*), public, parameter :: TOML_HEXDIGITS = & & ' 0123456789 ABCDEFabcdef ' character(kind=tfc, len=*), public, parameter :: TOML_TIMESTAMP = & & TOML_DIGITS//' .: +- T Zz ' !> Allowed characters in TOML bare keys. character(kind=tfc, len=*), public, parameter :: TOML_BAREKEY = & & TOML_LETTERS//TOML_DIGITS//' _ - ' character(kind=tfc, len=*), public, parameter :: TOML_LITERALS = & & TOML_LETTERS//TOML_DIGITS//' _ -+ . ' end module tomlf_constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"build.f90 – TOML-Fortran","text":"Contents Modules tomlf_build Source Code build.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build a TOML data structures !> !> The build module defines a high level interface to work with TOML data structures !> and construct them in a convenient way. module tomlf_build use tomlf_build_array , only : get_value , set_value use tomlf_build_keyval , only : get_value , set_value use tomlf_build_merge , only : merge_table , merge_array use tomlf_build_table , only : get_value , set_value implicit none private public :: get_value , set_value , merge_table , merge_array end module tomlf_build","tags":"","loc":"sourcefile/build.f90.html"},{"title":"type.f90 – TOML-Fortran","text":"Contents Modules tomlf_type Source Code type.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Collection of the central datatypes to define TOML data structures !> !> All TOML data types should inherit from an abstract value allowing to generate !> a generic interface to deal with all more specialized TOML data types, while !> the abstract value is interesting for developing algorithms in TOML-Fortran, !> the user of TOML-Fortran will usually only care about TOML tables and possibly !> arrays. !> !> The TOML types defined here should implement the TOML data structures (mostly) !> without taking the actual implementation of the data structures into account. !> This is done by providing a bare minimum interface using type bound procedures !> to minimize the interdependencies between the datatypes. !> !> To make the data types extendable a visitor pattern allows access to the TOML !> data types and can be used to implement further algorithms. module tomlf_type use tomlf_constants , only : tfc use tomlf_error , only : toml_stat use tomlf_type_array , only : toml_array , new_array , new , len use tomlf_type_keyval , only : toml_keyval , new_keyval , new use tomlf_type_table , only : toml_table , new_table , new use tomlf_type_value , only : toml_value , toml_visitor , toml_key implicit none private public :: toml_value , toml_visitor , toml_table , toml_array , toml_keyval public :: toml_key public :: new , new_table , new_array , new_keyval , len public :: add_table , add_array , add_keyval public :: is_array_of_tables !> Interface to build new tables interface add_table module procedure :: add_table_to_table module procedure :: add_table_to_array end interface add_table !> Interface to build new arrays interface add_array module procedure :: add_array_to_table module procedure :: add_array_to_array end interface add_array !> Interface to build new key-value pairs interface add_keyval module procedure :: add_keyval_to_table module procedure :: add_keyval_to_array end interface add_keyval contains !> Create a new TOML table inside an existing table subroutine add_table_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_table_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_table ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_table_to_table !> Create a new TOML array inside an existing table subroutine add_array_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new array character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_array_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_array ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_array_to_table !> Create a new key-value pair inside an existing table subroutine add_keyval_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new key-value pair character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created key-value pair type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_keyval_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_keyval ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_keyval_to_table !> Create a new TOML table inside an existing array subroutine add_table_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_table_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_table ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_table_to_array !> Create a new TOML array inside an existing array subroutine add_array_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) allocate ( toml_array :: val ) call new_array_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_array ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_array_to_array !> Create a new key-value pair inside an existing array subroutine add_keyval_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created key-value pair type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_keyval_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_keyval ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_keyval_to_array !> Wrapped constructor to create a new TOML table on an abstract TOML value subroutine new_table_ ( self ) !> Newly created TOML table class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_table ), allocatable :: val allocate ( val ) call new_table ( val ) call move_alloc ( val , self ) end subroutine new_table_ !> Wrapped constructor to create a new TOML array on an abstract TOML value subroutine new_array_ ( self ) !> Newly created TOML array class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_array ), allocatable :: val allocate ( val ) call new_array ( val ) call move_alloc ( val , self ) end subroutine new_array_ !> Wrapped constructor to create a new TOML array on an abstract TOML value subroutine new_keyval_ ( self ) !> Newly created key-value pair class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_keyval ), allocatable :: val allocate ( val ) call new_keyval ( val ) call move_alloc ( val , self ) end subroutine new_keyval_ !> Determine if array contains only tables function is_array_of_tables ( array ) result ( only_tables ) !> TOML value to visit class ( toml_array ), intent ( inout ) :: array !> Array contains only tables logical :: only_tables class ( toml_value ), pointer :: ptr integer :: i , n n = len ( array ) only_tables = n > 0 do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) type is ( toml_table ) cycle class default only_tables = . false . exit end select end do end function is_array_of_tables end module tomlf_type","tags":"","loc":"sourcefile/type.f90.html"},{"title":"utils.f90 – TOML-Fortran","text":"Contents Modules tomlf_utils Source Code utils.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module tomlf_utils use tomlf_constants use tomlf_datetime , only : toml_datetime , toml_date , toml_time use tomlf_utils_convert use tomlf_utils_verify implicit none private public :: convert_raw public :: toml_raw_to_string , toml_raw_to_float , toml_raw_to_bool public :: toml_raw_to_integer , toml_raw_to_timestamp public :: toml_raw_verify_string , toml_raw_verify_float , toml_raw_verify_bool public :: toml_raw_verify_integer , toml_raw_verify_timestamp public :: toml_raw_verify_date , toml_raw_verify_time public :: toml_escape_string , toml_get_value_type contains !> Determine TOML value type function toml_get_value_type ( raw ) result ( vtype ) !> Raw representation of TOML string character ( kind = tfc , len =* ), intent ( in ) :: raw !> Value type integer :: vtype if ( toml_raw_verify_string ( raw )) then vtype = toml_type % string return end if if ( toml_raw_verify_bool ( raw )) then vtype = toml_type % boolean return end if if ( toml_raw_verify_integer ( raw )) then vtype = toml_type % int return end if if ( toml_raw_verify_float ( raw )) then vtype = toml_type % float return end if if ( toml_raw_verify_timestamp ( raw )) then vtype = toml_type % datetime return end if vtype = toml_type % invalid end function !> Escape all special characters in a TOML string subroutine toml_escape_string ( raw , escaped ) !> Raw representation of TOML string character ( kind = tfc , len =* ), intent ( in ) :: raw !> Escaped view of the TOML string character ( kind = tfc , len = :), allocatable , intent ( out ) :: escaped integer :: i escaped = '\"' do i = 1 , len ( raw ) select case ( raw ( i : i )) case default ; escaped = escaped // raw ( i : i ) case ( '\\'); escaped = escaped // ' \\\\ ' case(' \"'); escaped = escaped // '\\\"' case(TOML_NEWLINE); escaped = escaped // '\\n' case(TOML_FORMFEED); escaped = escaped // '\\f' case(TOML_CARRIAGE_RETURN); escaped = escaped // '\\r' case(TOML_TABULATOR); escaped = escaped // '\\t' case(TOML_BACKSPACE); escaped = escaped // '\\b' end select end do escaped = escaped // '\" ' end subroutine toml_escape_string end module tomlf_utils","tags":"","loc":"sourcefile/utils.f90.html"},{"title":"de.f90 – TOML-Fortran","text":"Contents Modules tomlf_de Source Code de.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module tomlf_de use tomlf_constants , only : TOML_NEWLINE use tomlf_de_character , only : toml_character_tokenizer , new use tomlf_error , only : toml_error , io_error use tomlf_type , only : toml_table implicit none private public :: toml_parse interface toml_parse module procedure :: toml_parse_unit module procedure :: toml_parse_string end interface toml_parse contains !> Parse a TOML input from a given IO unit. subroutine toml_parse_unit ( table , unit , error ) use iso_fortran_env use tomlf_constants , only : TOML_NEWLINE type ( toml_table ), allocatable , intent ( out ) :: table integer , intent ( in ) :: unit type ( toml_error ), allocatable , intent ( out ), optional :: error character ( len = :), allocatable :: conf integer , parameter :: bufsize = 512 character ( len = bufsize ) :: buffer character ( len = bufsize ) :: error_msg integer :: size integer :: stat allocate ( character ( len = 0 ) :: conf ) do read ( unit , '(a)' , advance = 'no' , iostat = stat , iomsg = error_msg , size = size ) & & buffer if ( stat > 0 ) exit conf = conf // buffer (: size ) if ( stat < 0 ) then if ( is_iostat_eor ( stat )) then stat = 0 conf = conf // TOML_NEWLINE end if if ( is_iostat_end ( stat )) then stat = 0 exit end if end if end do if ( stat /= 0 ) then if ( present ( error )) then call io_error ( error , trim ( error_msg )) else write ( error_unit , '(a, /, a)' ) \"IO runtime error\" , trim ( error_msg ) end if return end if call toml_parse_string ( table , conf , error ) end subroutine toml_parse_unit !> Wrapper to parse a TOML string. subroutine toml_parse_string ( table , conf , error ) use iso_fortran_env , only : error_unit type ( toml_table ), allocatable , intent ( out ) :: table character ( len =* ), intent ( in ), target :: conf type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_character_tokenizer ) :: de !> connect deserializer to configuration call new ( de , conf ) call de % parse if ( allocated ( de % error )) then if ( present ( error )) then call move_alloc ( de % error , error ) else write ( error_unit , '(a)' ) de % error % message end if return end if call move_alloc ( de % root , table ) end subroutine toml_parse_string end module tomlf_de","tags":"","loc":"sourcefile/de.f90.html"},{"title":"error.f90 – TOML-Fortran","text":"Contents Modules tomlf_error Source Code error.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Central registry for error codes module tomlf_error use tomlf_constants , only : tfc , TOML_NEWLINE implicit none private public :: toml_stat , toml_error , toml_context public :: syntax_error , duplicate_key_error , io_error , vendor_error !> Possible TOML-Fortran error codes type :: enum_stat !> Successful run integer :: success = 0 !> Internal error: ! !  General undefined error state, usually caused by algorithmic errors. integer :: fatal = - 1 !> Duplicate key error: ! !  Tried to push back an already present key on a TOML table or !  TOML document contains duplicate keys, already present in table. integer :: duplicate_key = 1 !> Syntax error integer :: invalid_syntax = 2 !> IO error integer :: io_failure = 3 end type enum_stat !> Actual enumerator for return states type ( enum_stat ), parameter :: toml_stat = enum_stat () !> Context for error message (usually a line in a TOML document) type :: toml_context !> Current internal position integer :: pos = 0 !> Current internal count integer :: num = 0 !> Current internal location on the string buffer character ( kind = tfc , len = :), pointer :: ptr => null () end type toml_context !> Error message produced by TOML-Fortran type :: toml_error !> Error code integer :: stat = toml_stat % fatal !> Payload of the error character ( kind = tfc , len = :), allocatable :: message end type toml_error contains !> A syntactic error in a TOML document was found subroutine syntax_error ( error , context , message , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % invalid_syntax end if if ( present ( message )) then error % message = message else error % message = \"Syntax error\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine syntax_error !> Key is present multiple times in a TOML document within the same table subroutine duplicate_key_error ( error , context , key , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> The offending duplicate key character ( kind = tfc , len =* ), intent ( in ), optional :: key !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % duplicate_key end if if ( present ( key )) then error % message = \"Duplicate key (\" // key // \") found\" else error % message = \"Duplicate key found\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine duplicate_key_error !> IO runtime error subroutine io_error ( error , message ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message allocate ( error ) error % stat = toml_stat % io_failure if ( present ( message )) then error % message = message else error % message = \"IO runtime error\" end if end subroutine io_error !> A shortcoming in the implementation or an internal error occured, rather !  than falling back to unpredictable and possibly harmful behaviour, we try !  to offer an apology for this inconvenience subroutine vendor_error ( error , context , message , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Internal error\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine vendor_error !> Put an existing error message into a more useful context subroutine add_context ( message , context ) !> A detailed message describing the error, requiring some more context character ( len = :), allocatable , intent ( inout ) :: message !> Current context producing the error type ( toml_context ), intent ( in ) :: context character ( len = 20 ) :: num integer :: line_break if ( context % num > 0 ) then write ( num , '(\"line\",1x,i0,\":\")' ) context % num message = num ( 1 : len_trim ( num ) + 1 ) // message end if if ( associated ( context % ptr )) then line_break = index ( context % ptr , TOML_NEWLINE ) - 1 if ( line_break < 0 ) line_break = len ( context % ptr ) message = message // TOML_NEWLINE // & & '   | ' // context % ptr ( 1 : line_break ) // TOML_NEWLINE // & & '   |' if ( context % pos > 0 . and . context % pos <= line_break ) then message = message // repeat ( '-' , context % pos ) // '&#94;' end if end if end subroutine add_context end module tomlf_error","tags":"","loc":"sourcefile/error.f90.html"},{"title":"ser.f90 – TOML-Fortran","text":"Contents Modules tomlf_ser Source Code ser.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> TOML serializer implementation module tomlf_ser use tomlf_constants , only : tfc , tfout use tomlf_type , only : toml_value , toml_visitor , toml_key , toml_table , & & toml_array , toml_keyval , is_array_of_tables , len implicit none private public :: toml_serializer , new_serializer , new !> TOML serializer to produduce a TOML document from a datastructure type , extends ( toml_visitor ) :: toml_serializer !> Unit for output integer :: unit = tfout !> Special mode for printing array of tables logical , private :: array_of_tables = . false . !> Special mode for printing inline arrays logical , private :: inline_array = . false . !> Top of the key stack integer , private :: top = 0 !> Key stack to create table headers type ( toml_key ), allocatable , private :: stack (:) contains !> Visit a TOML value procedure :: visit end type toml_serializer !> Create standard constructor interface toml_serializer module procedure :: new_serializer_func end interface toml_serializer !> Overloaded constructor for TOML serializers interface new module procedure :: new_serializer end interface !> Initial size of the key path stack integer , parameter :: initial_size = 8 contains !> Constructor to create new serializer instance subroutine new_serializer ( self , unit ) !> Instance of the TOML serializer type ( toml_serializer ), intent ( out ) :: self !> Unit for IO integer , intent ( in ), optional :: unit if ( present ( unit )) then self % unit = unit end if end subroutine new_serializer !> Default constructor for TOML serializer function new_serializer_func ( unit ) result ( self ) !> Unit for IO integer , intent ( in ), optional :: unit !> Instance of the TOML serializer type ( toml_serializer ) :: self call new_serializer ( self , unit ) end function new_serializer_func !> Visit a TOML value subroutine visit ( self , val ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: self !> TOML value to visit class ( toml_value ), intent ( inout ) :: val select type ( val ) class is ( toml_keyval ) call visit_keyval ( self , val ) class is ( toml_array ) call visit_array ( self , val ) class is ( toml_table ) call visit_table ( self , val ) end select end subroutine visit !> Visit a TOML key-value pair subroutine visit_keyval ( visitor , keyval ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML value to visit type ( toml_keyval ), intent ( inout ) :: keyval character ( kind = tfc , len = :), allocatable :: key call keyval % get_key ( key ) if ( visitor % inline_array ) then write ( visitor % unit , '(1x,a,1x,\"=\",1x,a,\",\")' , advance = 'no' ) & & key , keyval % raw else write ( visitor % unit , '(a,1x,\"=\",1x,a)' ) key , keyval % raw end if end subroutine visit_keyval !> Visit a TOML array subroutine visit_array ( visitor , array ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML value to visit type ( toml_array ), intent ( inout ) :: array class ( toml_value ), pointer :: ptr character ( kind = tfc , len = :), allocatable :: key integer :: i , n if ( visitor % inline_array ) write ( visitor % unit , '(1x,\"[\")' , advance = 'no' ) n = len ( array ) do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) class is ( toml_keyval ) write ( visitor % unit , '(1x,a)' , advance = 'no' ) ptr % raw if ( i /= n ) write ( visitor % unit , '(\",\")' , advance = 'no' ) class is ( toml_array ) call ptr % accept ( visitor ) if ( i /= n ) write ( visitor % unit , '(\",\")' , advance = 'no' ) class is ( toml_table ) if ( visitor % inline_array ) then write ( visitor % unit , '(1x,\"{\")' , advance = 'no' ) call ptr % accept ( visitor ) write ( visitor % unit , '(1x,\"}\")' , advance = 'no' ) if ( i /= n ) write ( visitor % unit , '(\",\")' , advance = 'no' ) else visitor % array_of_tables = . true . if ( size ( visitor % stack , 1 ) <= visitor % top ) call resize ( visitor % stack ) visitor % top = visitor % top + 1 call array % get_key ( key ) visitor % stack ( visitor % top )% key = key call ptr % accept ( visitor ) deallocate ( visitor % stack ( visitor % top )% key ) visitor % top = visitor % top - 1 end if end select end do if ( visitor % inline_array ) write ( visitor % unit , '(1x,\"]\")' , advance = 'no' ) end subroutine visit_array !> Visit a TOML table subroutine visit_table ( visitor , table ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML table to visit type ( toml_table ), intent ( inout ) :: table class ( toml_value ), pointer :: ptr type ( toml_key ), allocatable :: list (:) logical , allocatable :: defer (:) character ( kind = tfc , len = :), allocatable :: key integer :: i , n call table % get_keys ( list ) n = size ( list , 1 ) allocate ( defer ( n )) if (. not . allocated ( visitor % stack )) then call resize ( visitor % stack ) else if (. not .( visitor % inline_array . or . table % implicit )) then write ( visitor % unit , '(\"[\")' , advance = 'no' ) if ( visitor % array_of_tables ) write ( visitor % unit , '(\"[\")' , advance = 'no' ) do i = 1 , visitor % top - 1 write ( visitor % unit , '(a,\".\")' , advance = 'no' ) visitor % stack ( i )% key end do write ( visitor % unit , '(a)' , advance = 'no' ) visitor % stack ( visitor % top )% key write ( visitor % unit , '(\"]\")' , advance = 'no' ) if ( visitor % array_of_tables ) write ( visitor % unit , '(\"]\")' , advance = 'no' ) write ( visitor % unit , '(a)' ) visitor % array_of_tables = . false . end if end if do i = 1 , n defer ( i ) = . false . call table % get ( list ( i )% key , ptr ) select type ( ptr ) class is ( toml_keyval ) call ptr % accept ( visitor ) class is ( toml_array ) if ( visitor % inline_array ) then call ptr % get_key ( key ) write ( visitor % unit , '(1x,a,1x,\"=\")' , advance = 'no' ) key call ptr % accept ( visitor ) if ( i /= n ) write ( visitor % unit , '(\",\")' , advance = 'no' ) else if ( is_array_of_tables ( ptr )) then ! Array of tables open a new section ! -> cannot serialize them before all key-value pairs are done defer ( i ) = . true . else visitor % inline_array = . true . call ptr % get_key ( key ) write ( visitor % unit , '(a,1x,\"=\")' , advance = 'no' ) key call ptr % accept ( visitor ) visitor % inline_array = . false . write ( visitor % unit , '(a)' ) end if end if class is ( toml_table ) ! Subtables open a new section ! -> cannot serialize them before all key-value pairs are done defer ( i ) = . true . end select end do do i = 1 , n if ( defer ( i )) then call table % get ( list ( i )% key , ptr ) select type ( ptr ) class is ( toml_keyval ) call ptr % accept ( visitor ) class is ( toml_array ) if ( visitor % inline_array ) then call ptr % get_key ( key ) write ( visitor % unit , '(1x,a,1x,\"=\")' , advance = 'no' ) key call ptr % accept ( visitor ) if ( i /= n ) write ( visitor % unit , '(\",\")' , advance = 'no' ) else if ( is_array_of_tables ( ptr )) then call ptr % accept ( visitor ) else visitor % inline_array = . true . call ptr % get_key ( key ) write ( visitor % unit , '(a,1x,\"=\")' , advance = 'no' ) key call ptr % accept ( visitor ) visitor % inline_array = . false . write ( visitor % unit , '(a)' ) end if end if class is ( toml_table ) if ( size ( visitor % stack , 1 ) <= visitor % top ) call resize ( visitor % stack ) visitor % top = visitor % top + 1 call ptr % get_key ( key ) visitor % stack ( visitor % top )% key = key call ptr % accept ( visitor ) deallocate ( visitor % stack ( visitor % top )% key ) visitor % top = visitor % top - 1 end select end if end do if (. not . visitor % inline_array . and . visitor % top == 0 ) then deallocate ( visitor % stack ) end if end subroutine visit_table !> Change size of the stack subroutine resize ( stack , n ) !> Stack of keys to be resized type ( toml_key ), allocatable , intent ( inout ) :: stack (:) !> New size of the stack integer , intent ( in ), optional :: n type ( toml_key ), allocatable :: tmp (:) integer :: m if ( present ( n )) then m = n else if ( allocated ( stack )) then m = size ( stack ) m = m + m / 2 + 1 else m = initial_size end if end if if ( allocated ( stack )) then call move_alloc ( stack , tmp ) allocate ( stack ( m )) m = min ( size ( tmp ), m ) stack (: m ) = tmp (: m ) deallocate ( tmp ) else allocate ( stack ( m )) end if end subroutine resize end module tomlf_ser","tags":"","loc":"sourcefile/ser.f90.html"},{"title":"structure.f90 – TOML-Fortran","text":"Contents Modules tomlf_structure Source Code structure.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Abstraction layer for the actual storage of the data structure. !> !> The structure implementations provide the actual storage for TOML values, with !> a generic enough interface to make the definition of the TOML data structures !> independent of the actual algorithm used for storing the TOML values. !> !> Every data structure defined here should strive to only use allocatable !> data types and limit the use of pointer attributes as they interfer with !> the automatic memory management of Fortran. A well defined data structure !> in allocatables allows deep-copying of TOML values by assignment, data structures !> requiring pointer attributes have to define an assignment(=) interface to !> allow deep-copying of TOML values. module tomlf_structure use tomlf_structure_base , only : toml_structure , toml_ordered use tomlf_structure_vector , only : toml_vector , new_vector implicit none private public :: toml_structure , toml_ordered public :: new_structure , new_ordered public :: len !> Overload len function interface len module procedure :: get_len end interface contains !> Constructor for the storage data structure subroutine new_structure ( self ) !> Instance of the structure class ( toml_structure ), allocatable , intent ( out ) :: self type ( toml_vector ), allocatable :: vect allocate ( vect ) call new_vector ( vect ) call move_alloc ( vect , self ) end subroutine new_structure !> Constructor for the ordered storage data structure subroutine new_ordered ( self ) !> Instance of the structure class ( toml_ordered ), allocatable , intent ( out ) :: self type ( toml_vector ), allocatable :: vect allocate ( vect ) call new_vector ( vect ) call move_alloc ( vect , self ) end subroutine new_ordered !> Get number of TOML values in the structure pure function get_len ( self ) result ( length ) !> Instance of the structure class ( toml_ordered ), intent ( in ) :: self !> Current length of the ordered structure integer :: length length = self % get_len () end function get_len end module tomlf_structure","tags":"","loc":"sourcefile/structure.f90.html"},{"title":"version.f90 – TOML-Fortran","text":"Contents Modules tomlf_version Source Code version.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Version information on TOML-Fortran module tomlf_version implicit none private public :: get_tomlf_version public :: tomlf_version_string , tomlf_version_compact !> String representation of the TOML-Fortran version character ( len =* ), parameter :: tomlf_version_string = \"0.2.1\" !> Major version number of the above TOML-Fortran version integer , parameter :: tomlf_major = 0 !> Minor version number of the above TOML-Fortran version integer , parameter :: tomlf_minor = 2 !> Patch version number of the above TOML-Fortran version integer , parameter :: tomlf_patch = 1 !> Compact numeric representation of the TOML-Fortran version integer , parameter :: tomlf_version_compact = & & tomlf_major * 10000 + tomlf_minor * 100 + tomlf_patch contains !> Getter function to retrieve TOML-Fortran version subroutine get_tomlf_version ( major , minor , patch , string ) !> Major version number of the TOML-Fortran version integer , intent ( out ), optional :: major !> Minor version number of the TOML-Fortran version integer , intent ( out ), optional :: minor !> Patch version number of the TOML-Fortran version integer , intent ( out ), optional :: patch !> String representation of the TOML-Fortran version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = tomlf_major end if if ( present ( minor )) then minor = tomlf_minor end if if ( present ( patch )) then patch = tomlf_patch end if if ( present ( string )) then string = tomlf_version_string end if end subroutine get_tomlf_version end module tomlf_version","tags":"","loc":"sourcefile/version.f90.html"},{"title":"table.f90 – TOML-Fortran","text":"Contents Modules tomlf_build_table Source Code table.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build TOML tables !> !> The build module defines a high level interface to work with TOML tables !> and construct them in a convenient way. !> !> The getter functions allow to both retrieve and set values, to easily !> support default values when reading from a TOML data structure. !> Using the getter function with a default value specified will request !> the respective setter function to add it to the table if it was not !> found in the first place. !> !> This allows to build a TOML table using only the getter functions, which !> represents the finally read values for the applications. !> !> Note that neither setter nor getter functions can overwrite existing !> TOML values for safety reasons, request the deletion on the respective !> key from the TOML table and than set it. The deletion of a subtable or !> array will recursively destroy the contained data nodes. module tomlf_build_table use tomlf_build_keyval , only : get_value , set_value use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , len implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML tables interface set_value module procedure :: set_child_value_float_sp module procedure :: set_child_value_float_dp module procedure :: set_child_value_integer_i1 module procedure :: set_child_value_integer_i2 module procedure :: set_child_value_integer_i4 module procedure :: set_child_value_integer_i8 module procedure :: set_child_value_bool module procedure :: set_child_value_string end interface set_value !> Getter functions to manipulate TOML tables interface get_value module procedure :: get_child_table module procedure :: get_child_array module procedure :: get_child_keyval module procedure :: get_child_value_float_sp module procedure :: get_child_value_float_dp module procedure :: get_child_value_integer_i1 module procedure :: get_child_value_integer_i2 module procedure :: get_child_value_integer_i4 module procedure :: get_child_value_integer_i8 module procedure :: get_child_value_bool module procedure :: get_child_value_string end interface get_value contains subroutine get_child_table ( table , key , ptr , requested , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp logical :: is_requested if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_table ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( is_requested ) then call add_table ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if end if end subroutine get_child_table subroutine get_child_array ( table , key , ptr , requested , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp logical :: is_requested if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_array ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( is_requested ) then call add_array ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if end if end subroutine get_child_array subroutine get_child_keyval ( table , key , ptr , requested , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp logical :: is_requested if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_keyval ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( is_requested ) then call add_keyval ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if end if end subroutine get_child_keyval !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_child_value_float_sp ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( out ) :: val !> Default real value real ( tf_sp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_float_sp !> Retrieve TOML value as double precision float subroutine get_child_value_float_dp ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( out ) :: val !> Default real value real ( tf_dp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_child_value_integer_i1 ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Default integer value integer ( tf_i1 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_child_value_integer_i2 ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Default integer value integer ( tf_i2 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_child_value_integer_i4 ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Default integer value integer ( tf_i4 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_child_value_integer_i8 ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Default integer value integer ( tf_i8 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_integer_i8 !> Retrieve TOML value as logical subroutine get_child_value_bool ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Boolean value logical , intent ( out ) :: val !> Default boolean value logical , intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_bool !> Retrieve TOML value as deferred-length character subroutine get_child_value_string ( table , key , val , default , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Default string value character ( kind = tfc , len =* ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat ) if ( associated ( ptr )) then if ( allocated ( ptr % raw )) then call get_value ( ptr , val , stat ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if end if end subroutine get_child_value_string !> Set TOML value to single precision float subroutine set_child_value_float_sp ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_float_sp !> Set TOML value to double precision float subroutine set_child_value_float_dp ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_float_dp !> Set TOML value to one byte integer subroutine set_child_value_integer_i1 ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i1 !> Set TOML value to two byte integer subroutine set_child_value_integer_i2 ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i2 !> Set TOML value to four byte integer subroutine set_child_value_integer_i4 ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_child_value_integer_i8 ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i8 !> Set TOML value to logical subroutine set_child_value_bool ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_bool !> Set TOML value to deferred-length character subroutine set_child_value_string ( table , key , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat ) if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_string end module tomlf_build_table","tags":"","loc":"sourcefile/table.f90.html"},{"title":"array.f90 – TOML-Fortran","text":"Contents Modules tomlf_build_array Source Code array.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build TOML arrays. !> !> This build module defines a high level interface to work with TOML arrays !> and construct them in a convenient way. !> !> The access to the array elements happens by position in the array, the indexing !> is one based, following the language convention of Fortran. All functions !> will only allow access of elements within the bounds of the array, specifying !> indices out-of-bounds should be save, as it only sets the status of operation. !> The getter functions allow access to other tables and arrays as well as !> convenient wrappers to retrieve value data !> !> The setter functions are somewhat weaker compared to the setter functions !> available for TOML tables. To limit the potential havoc this routines can !> cause they can only access the array within its bounds. Setting a value to !> another value will overwrite it, while setting a value to a table or an array !> will fail, for safety reasons. !> !> To (re)build an array appending to it is the best choice, tables and arrays !> should always be create by using the corresponding `add_table` and `add_array` !> function. While this can become cumbersome for values, the setter routines !> allow out-of-bound access to for the next element in an array and will indeed !> just append a new value to it. module tomlf_build_array use tomlf_build_keyval , only : get_value , set_value use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , len use tomlf_utils , only : toml_raw_to_string , toml_raw_to_float , & & toml_raw_to_bool , toml_raw_to_integer , toml_raw_to_timestamp implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML arrays interface set_value module procedure :: set_elem_value_string module procedure :: set_elem_value_float_sp module procedure :: set_elem_value_float_dp module procedure :: set_elem_value_int_i1 module procedure :: set_elem_value_int_i2 module procedure :: set_elem_value_int_i4 module procedure :: set_elem_value_int_i8 module procedure :: set_elem_value_bool end interface set_value !> Getter functions to manipulate TOML arrays interface get_value module procedure :: get_elem_table module procedure :: get_elem_array module procedure :: get_elem_keyval module procedure :: get_elem_value_string module procedure :: get_elem_value_float_sp module procedure :: get_elem_value_float_dp module procedure :: get_elem_value_int_i1 module procedure :: get_elem_value_int_i2 module procedure :: get_elem_value_int_i4 module procedure :: get_elem_value_int_i8 module procedure :: get_elem_value_bool end interface get_value contains subroutine get_elem_table ( array , pos , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_table ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_table subroutine get_elem_array ( array , pos , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_array ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_array subroutine get_elem_keyval ( array , pos , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_keyval ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_keyval !> Retrieve TOML value as deferred-length character subroutine get_elem_value_string ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_string !> Retrieve TOML value as single precision floating point number subroutine get_elem_value_float_sp ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_sp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine get_elem_value_float_dp ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_dp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_float_dp !> Retrieve TOML value as integer value subroutine get_elem_value_int_i1 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i1 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i2 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i2 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i4 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i4 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i8 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i8 !> Retrieve TOML value as boolean subroutine get_elem_value_bool ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value logical , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if ( associated ( ptr )) then call get_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_bool !> Retrieve TOML value as deferred-length character subroutine set_elem_value_string ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_string !> Retrieve TOML value as single precision floating point number subroutine set_elem_value_float_sp ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine set_elem_value_float_dp ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_float_dp !> Retrieve TOML value as integer value subroutine set_elem_value_int_i1 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i1 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i2 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i2 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i4 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i4 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i8 ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i8 !> Retrieve TOML value as boolean value subroutine set_elem_value_bool ( array , pos , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_bool end module tomlf_build_array","tags":"","loc":"sourcefile/array.f90.html"},{"title":"keyval.f90 – TOML-Fortran","text":"Contents Modules tomlf_build_keyval Source Code keyval.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build a TOML values !> !> The build module defines an interface to work with TOML values instead !> of accessing the raw value directly. Both setter and getter routines defined !> here are rarely needed in any user context, but serve as a basic building !> block to define uniform access methods for TOML tables and arrays. module tomlf_build_keyval use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp , TOML_NEWLINE use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , len use tomlf_utils , only : toml_raw_to_string , toml_raw_to_float , & & toml_raw_to_bool , toml_raw_to_integer , toml_raw_to_timestamp , & & toml_raw_verify_string implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML values interface set_value module procedure :: set_value_float_sp module procedure :: set_value_float_dp module procedure :: set_value_integer_i1 module procedure :: set_value_integer_i2 module procedure :: set_value_integer_i4 module procedure :: set_value_integer_i8 module procedure :: set_value_bool module procedure :: set_value_string end interface set_value !> Getter functions to manipulate TOML values interface get_value module procedure :: get_value_float_sp module procedure :: get_value_float_dp module procedure :: get_value_integer_i1 module procedure :: get_value_integer_i2 module procedure :: get_value_integer_i4 module procedure :: get_value_integer_i8 module procedure :: get_value_bool module procedure :: get_value_string end interface get_value !> Length for the static character variables integer , parameter :: buffersize = 128 contains !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_value_float_sp ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Real value real ( tf_sp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat real ( tfr ) :: dummy istat = toml_raw_to_float ( self % raw , dummy ) if ( istat ) then val = real ( dummy , tf_sp ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_float_sp !> Retrieve TOML value as double precision float subroutine get_value_float_dp ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Real value real ( tf_dp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat real ( tfr ) :: dummy istat = toml_raw_to_float ( self % raw , dummy ) if ( istat ) then val = real ( dummy , tf_dp ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_value_integer_i1 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat integer ( tfi ) :: dummy istat = toml_raw_to_integer ( self % raw , dummy ) if ( istat ) then val = int ( dummy , tf_i1 ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_value_integer_i2 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat integer ( tfi ) :: dummy istat = toml_raw_to_integer ( self % raw , dummy ) if ( istat ) then val = int ( dummy , tf_i2 ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_value_integer_i4 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat integer ( tfi ) :: dummy istat = toml_raw_to_integer ( self % raw , dummy ) if ( istat ) then val = int ( dummy , tf_i4 ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_value_integer_i8 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat integer ( tfi ) :: dummy istat = toml_raw_to_integer ( self % raw , dummy ) if ( istat ) then val = int ( dummy , tf_i8 ) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_integer_i8 !> Retrieve TOML value as logical subroutine get_value_bool ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Boolean value logical , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat istat = toml_raw_to_bool ( self % raw , val ) if ( istat ) then if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_bool !> Retrieve TOML value as deferred-length character subroutine get_value_string ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat logical :: istat istat = toml_raw_to_string ( self % raw , val ) if ( istat ) then if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_value_string !> Set TOML value to single precision float subroutine set_value_float_sp ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(es30.6)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_float_sp !> Set TOML value to double precision float subroutine set_value_float_dp ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(es30.16)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_float_dp !> Set TOML value to one byte integer subroutine set_value_integer_i1 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(i0)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_integer_i1 !> Set TOML value to two byte integer subroutine set_value_integer_i2 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(i0)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_integer_i2 !> Set TOML value to four byte integer subroutine set_value_integer_i4 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(i0)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_value_integer_i8 ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat character ( kind = tfc , len = buffersize ) :: tmp integer :: istat write ( tmp , '(i0)' , iostat = istat ) val if ( istat == 0 ) then self % raw = trim ( adjustl ( tmp )) if ( present ( stat )) stat = toml_stat % success else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_value_integer_i8 !> Set TOML value to logical subroutine set_value_bool ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat if ( val ) then self % raw = 'true' else self % raw = 'false' end if if ( present ( stat )) stat = toml_stat % success end subroutine set_value_bool !> Set TOML value to deferred-length character subroutine set_value_string ( self , val , stat ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat if ( toml_raw_verify_string ( val )) then self % raw = val else if ( index ( val , TOML_NEWLINE ) > 0 ) then self % raw = '\"\"\"' // val // '\"\"\"' else self % raw = '\"' // val // '\"' end if end if if ( present ( stat )) stat = toml_stat % success end subroutine set_value_string end module tomlf_build_keyval","tags":"","loc":"sourcefile/keyval.f90.html"},{"title":"merge.f90 – TOML-Fortran","text":"Contents Modules tomlf_build_merge Source Code merge.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Merge TOML data structures. !> !> Merge policy: !> - copy key-value pair in case it is not present in table !> - copy subtable in case it is not present in table !> - copy array in case it is not present in table !> - merge subtable in case it is present in table !> - append array in case it is present in table module tomlf_build_merge use tomlf_constants , only : tfc use tomlf_type , only : toml_table , toml_array , toml_keyval , toml_value , & & toml_key , len implicit none private public :: merge_table , merge_array contains !> Merge TOML tables by appending their values recursive subroutine merge_table ( lhs , rhs ) !> Instance of table to merge into class ( toml_table ), intent ( inout ) :: lhs !> Instance of table to be merged class ( toml_table ), intent ( inout ) :: rhs type ( toml_key ), allocatable :: list (:) class ( toml_value ), pointer :: ptr1 , ptr2 class ( toml_value ), allocatable :: tmp logical :: has_key integer :: i , n , stat call rhs % get_keys ( list ) n = size ( list , 1 ) do i = 1 , n if ( allocated ( tmp )) deallocate ( tmp ) call rhs % get ( list ( i )% key , ptr1 ) has_key = lhs % has_key ( list ( i )% key ) select type ( ptr1 ) class is ( toml_keyval ) if (. not . has_key ) then allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if class is ( toml_array ) if ( has_key ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_array ) call merge_array ( ptr2 , ptr1 ) end select else allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if class is ( toml_table ) if ( has_key ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_table ) call merge_table ( ptr2 , ptr1 ) end select else allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if end select end do end subroutine merge_table !> Append values from one TOML array to another recursive subroutine merge_array ( lhs , rhs ) !> Instance of array to merge into class ( toml_array ), intent ( inout ) :: lhs !> Instance of array to be merged class ( toml_array ), intent ( inout ) :: rhs class ( toml_value ), pointer :: ptr class ( toml_value ), allocatable :: tmp integer :: n , i , stat n = len ( rhs ) do i = 1 , n call rhs % get ( i , ptr ) if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp , source = ptr ) call lhs % push_back ( tmp , stat ) end do end subroutine merge_array end module tomlf_build_merge","tags":"","loc":"sourcefile/merge.f90.html"},{"title":"base.f90 – TOML-Fortran","text":"Contents Modules tomlf_structure_base Source Code base.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Abstract base class definitions for data structures to store TOML values module tomlf_structure_base use tomlf_constants , only : tfc use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_structure , toml_ordered !> Abstract data structure type , abstract :: toml_structure contains !> Find a TOML value based on its key procedure ( find ), deferred :: find !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Get list of all keys in the structure procedure ( get_keys ), deferred :: get_keys !> Delete TOML value at a given key procedure ( delete ), deferred :: delete !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_structure !> Ordered data structure, allows iterations type , abstract , extends ( toml_structure ) :: toml_ordered contains !> Get number of TOML values in the structure procedure ( get_len ), deferred :: get_len !> Remove the first element from the structure procedure ( shift ), deferred :: shift !> Remove the last element from the structure procedure ( pop ), deferred :: pop !> Get TOML value at a given index procedure ( get ), deferred :: get end type toml_ordered abstract interface !> Find a TOML value based on its key subroutine find ( self , key , ptr ) import :: toml_structure , toml_value , tfc !> Instance of the structure class ( toml_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the stored value at given key class ( toml_value ), pointer , intent ( out ) :: ptr end subroutine find !> Get number of TOML values in the structure pure function get_len ( self ) result ( length ) import :: toml_ordered !> Instance of the structure class ( toml_ordered ), intent ( in ), target :: self !> Current length of the ordered structure integer :: length end function get_len !> Get TOML value at a given index subroutine get ( self , idx , ptr ) import :: toml_ordered , toml_value !> Instance of the structure class ( toml_ordered ), intent ( inout ), target :: self !> Position in the ordered structure integer , intent ( in ) :: idx !> Pointer to the stored value at given index class ( toml_value ), pointer , intent ( out ) :: ptr end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) import :: toml_structure , toml_value !> Instance of the structure class ( toml_structure ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) import :: toml_ordered , toml_value !> Instance of the structure class ( toml_ordered ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) import :: toml_ordered , toml_value !> Instance of the structure class ( toml_ordered ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val end subroutine pop !> Get list of all keys in the structure subroutine get_keys ( self , list ) import :: toml_structure , toml_key !> Instance of the structure class ( toml_structure ), intent ( inout ), target :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) end subroutine get_keys !> Delete TOML value at a given key subroutine delete ( self , key ) import :: toml_structure , toml_value , tfc !> Instance of the structure class ( toml_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key end subroutine delete !> Deconstructor for data structure subroutine destroy ( self ) import :: toml_structure !> Instance of the structure class ( toml_structure ), intent ( inout ), target :: self end subroutine destroy end interface end module tomlf_structure_base","tags":"","loc":"sourcefile/base.f90.html"},{"title":"vector.f90 – TOML-Fortran","text":"Contents Modules tomlf_structure_vector Source Code vector.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a basic storage structure as pointer list of pointers. !> !> This implementation does purposely not use pointer attributes in the !> datastructure to make it safer to work with. module tomlf_structure_vector use tomlf_constants , only : tfc use tomlf_structure_base , only : toml_ordered use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_vector , new_vector !> Wrapped TOML value to generate pointer list type :: toml_node !> TOML value payload class ( toml_value ), allocatable :: val end type toml_node !> Stores TOML values in a list of pointers type , extends ( toml_ordered ) :: toml_vector !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get number of TOML values in the structure procedure :: get_len !> Find a TOML value based on its key procedure :: find !> Get TOML value at a given index procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove the first element from the structure procedure :: shift !> Remove the last element from the structure procedure :: pop !> Get list of all keys in the structure procedure :: get_keys !> Delete TOML value at a given key procedure :: delete !> Destroy the data structure procedure :: destroy end type toml_vector !> Initial storage capacity of the datastructure integer , parameter :: initial_size = 16 contains !> Constructor for the storage data structure subroutine new_vector ( self , n ) !> Instance of the structure type ( toml_vector ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_vector !> Get number of TOML values in the structure pure function get_len ( self ) result ( length ) !> Instance of the structure class ( toml_vector ), intent ( in ), target :: self !> Current length of the ordered structure integer :: length length = self % n end function get_len !> Find a TOML value based on its key subroutine find ( self , key , ptr ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the stored value at given key class ( toml_value ), pointer , intent ( out ) :: ptr integer :: i nullify ( ptr ) do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( self % lst ( i )% val % match_key ( key )) then ptr => self % lst ( i )% val exit end if end if end do end subroutine find !> Get TOML value at a given index subroutine get ( self , idx , ptr ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> Position in the ordered structure integer , intent ( in ) :: idx !> Pointer to the stored value at given index class ( toml_value ), pointer , intent ( out ) :: ptr nullify ( ptr ) if ( idx > 0 . and . idx <= self % n ) then if ( allocated ( self % lst ( idx )% val )) then ptr => self % lst ( idx )% val end if end if end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val integer :: m if (. not . allocated ( self % lst )) then call resize ( self % lst , initial_size ) end if m = size ( self % lst ) if ( self % n >= m ) then call resize ( self % lst , m + m / 2 + 1 ) end if self % n = self % n + 1 call move_alloc ( val , self % lst ( self % n )% val ) end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val integer :: i if ( self % n > 0 ) then call move_alloc ( self % lst ( 1 )% val , val ) do i = 2 , self % n call move_alloc ( self % lst ( i )% val , self % lst ( i - 1 )% val ) end do self % n = self % n - 1 end if end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val if ( self % n > 0 ) then call move_alloc ( self % lst ( self % n )% val , val ) self % n = self % n - 1 end if end subroutine pop !> Get list of all keys in the structure subroutine get_keys ( self , list ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) integer :: i allocate ( list ( self % n )) do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( allocated ( self % lst ( i )% val % key )) then list ( i )% key = self % lst ( i )% val % key end if end if end do end subroutine get_keys !> Delete TOML value at a given key subroutine delete ( self , key ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key integer :: idx , i idx = 0 do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( self % lst ( i )% val % match_key ( key )) then idx = i exit end if end if end do if ( idx > 0 ) then call self % lst ( idx )% val % destroy do i = idx + 1 , self % n call move_alloc ( self % lst ( i )% val , self % lst ( i - 1 )% val ) end do self % n = self % n - 1 end if end subroutine delete !> Change size of the TOML value vector subroutine resize ( list , n ) !> Array of TOML values to be resized type ( toml_node ), allocatable , intent ( inout ), target :: list (:) !> New size of the list integer , intent ( in ) :: n type ( toml_node ), allocatable , target :: tmp (:) integer :: i if ( allocated ( list )) then call move_alloc ( list , tmp ) allocate ( list ( n )) do i = 1 , min ( size ( tmp ), n ) if ( allocated ( tmp ( i )% val )) then call move_alloc ( tmp ( i )% val , list ( i )% val ) end if end do do i = n + 1 , size ( tmp ) if ( allocated ( tmp ( i )% val )) then call tmp ( i )% val % destroy deallocate ( tmp ( i )% val ) end if end do deallocate ( tmp ) else allocate ( list ( n )) end if end subroutine resize !> Deconstructor for data structure subroutine destroy ( self ) !> Instance of the structure class ( toml_vector ), intent ( inout ), target :: self integer :: i do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then call self % lst ( i )% val % destroy end if end do deallocate ( self % lst ) self % n = 0 end subroutine destroy end module tomlf_structure_vector","tags":"","loc":"sourcefile/vector.f90.html"},{"title":"verify.f90 – TOML-Fortran","text":"Contents Modules tomlf_utils_verify Source Code verify.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Contains utilities to verify TOML raw values correspond to a certain datatype module tomlf_utils_verify use tomlf_constants implicit none private public :: toml_raw_verify_string , toml_raw_verify_float , toml_raw_verify_bool public :: toml_raw_verify_integer , toml_raw_verify_timestamp public :: toml_raw_verify_date , toml_raw_verify_time contains !> Verify a raw value as TOML string pure function toml_raw_verify_string ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat stat = raw ( 1 : 1 ) == TOML_SQUOTE . or . raw ( 1 : 1 ) == TOML_DQUOTE end function toml_raw_verify_string !> Verify a raw value as TOML float pure function toml_raw_verify_float ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat logical :: plus_minus integer :: first integer :: dot_pos integer :: exp_pos first = 1 stat = . false . if ( raw == 'nan' ) then stat = . true . return end if ! allow leading + or - plus_minus = raw ( 1 : 1 ) == '+' . or . raw ( 1 : 1 ) == '-' if ( plus_minus ) first = first + 1 ! allow infinity and not-a-number if ( raw ( first :) == 'inf' . or . raw ( first :) == 'nan' ) then stat = . true . return end if ! position of dot and exponent dot_pos = index ( raw , '.' ) exp_pos = scan ( raw , 'Ee' ) if ( dot_pos == 0 . and . exp_pos == 0 ) return if ( dot_pos > 0 . and . exp_pos > 0 . and . dot_pos > exp_pos ) return ! check for leading or trailing underscores if ( raw ( first : first ) == '_' . or . raw ( len ( raw ):) == '_' ) return ! check for leading or trailing dots if ( first == dot_pos . or . len ( raw ) == dot_pos ) return if ( dot_pos > 0 ) then if ( raw ( dot_pos + 1 : dot_pos + 1 ) == '_' . or . raw ( dot_pos - 1 : dot_pos - 1 ) == '_' ) return end if ! zero must be followed by a dot or exponent if ( raw ( first : first ) == '0' . and . len ( raw ( first :)) > 1 ) then if ( first + 1 /= dot_pos . and . first + 1 /= exp_pos ) return end if ! no double underscores if ( index ( raw , '__' ) > 0 ) return ! check for digits stat = verify ( raw ( first :), TOML_DIGITS // '._-+eE' ) == 0 end function toml_raw_verify_float !> Verify a raw value as TOML integer pure function toml_raw_verify_integer ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat logical :: plus_minus integer :: first , base first = 1 base = 10 stat = . false . ! allow leading + or - plus_minus = raw ( 1 : 1 ) == '+' . or . raw ( 1 : 1 ) == '-' if ( plus_minus ) first = first + 1 ! check for leading underscores if ( raw ( first : first ) == '_' ) return ! no double underscores if ( index ( raw , '__' ) > 0 ) return ! 0 indicates other base systems if ( raw ( first : first ) == '0' . and . len ( raw ) > first ) then select case ( raw ( first + 1 : first + 1 )) case ( 'x' ); base = 16 case ( 'o' ); base = 8 case ( 'b' ); base = 2 case default ; return ! disallow 0[0-9_]+ end select first = first + 2 ! check for leading underscores, again if ( raw ( first : first ) == '_' ) return end if ! check for trailing underscores if ( raw ( len ( raw ):) == '_' ) return ! verify we only allowed digits select case ( base ) case default stat = verify ( raw ( first :), TOML_DIGITS // '_' ) == 0 case ( 16 ) stat = verify ( raw ( first :), TOML_HEXDIGITS // '_' ) == 0 case ( 8 ) stat = verify ( raw ( first :), TOML_OCTDIGITS // '_' ) == 0 case ( 2 ) stat = verify ( raw ( first :), TOML_BINDIGITS // '_' ) == 0 end select end function !> Verify a raw value as TOML bool pure function toml_raw_verify_bool ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat stat = raw == 'true' . or . raw == 'false' end function toml_raw_verify_bool !> Verify a raw value as TOML datetime expression pure function toml_raw_verify_timestamp ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat integer :: first first = 1 stat = . false . if ( toml_raw_verify_date ( raw )) then if ( len ( raw ) == 10 ) then stat = . true . return end if if ( raw ( 11 : 11 ) /= ' ' . and . raw ( 11 : 11 ) /= 'T' ) return first = 12 end if stat = toml_raw_verify_time ( raw ( first :)) end function toml_raw_verify_timestamp !> Verify a raw value as TOML date expression (YYYY-MM-DD) pure function toml_raw_verify_date ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat if ( len ( raw ) >= 10 ) then stat = verify ( raw ( 1 : 4 ), TOML_DIGITS ) == 0 . and . raw ( 5 : 5 ) == '-' . and . & & verify ( raw ( 6 : 7 ), TOML_DIGITS ) == 0 . and . raw ( 8 : 8 ) == '-' . and . & & verify ( raw ( 9 : 10 ), TOML_DIGITS ) == 0 else stat = . false . end if end function toml_raw_verify_date !> Verify a raw value as TOML time expression (HH:MM:SS) pure function toml_raw_verify_time ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat if ( len ( raw ) >= 8 ) then stat = verify ( raw ( 1 : 2 ), TOML_DIGITS ) == 0 . and . raw ( 3 : 3 ) == ':' . and . & & verify ( raw ( 4 : 5 ), TOML_DIGITS ) == 0 . and . raw ( 6 : 6 ) == ':' . and . & & verify ( raw ( 7 : 8 ), TOML_DIGITS ) == 0 else stat = . false . end if end function toml_raw_verify_time end module tomlf_utils_verify","tags":"","loc":"sourcefile/verify.f90.html"},{"title":"convert.f90 – TOML-Fortran","text":"Contents Modules tomlf_utils_convert Source Code convert.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Contains utilities to convert TOML raw values to actual Fortran datatypes module tomlf_utils_convert use tomlf_constants use tomlf_datetime , only : toml_datetime , toml_date , toml_time use tomlf_utils_verify implicit none private public :: convert_raw public :: toml_raw_to_string , toml_raw_to_float , toml_raw_to_bool public :: toml_raw_to_integer , toml_raw_to_timestamp !> Overloaded conversion interface interface convert_raw module procedure :: toml_raw_to_string module procedure :: toml_raw_to_float module procedure :: toml_raw_to_bool module procedure :: toml_raw_to_integer module procedure :: toml_raw_to_timestamp end interface convert_raw contains !> Attempt to convert TOML raw value to Fortran real function toml_raw_to_float ( raw , num ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> Real value represented by raw value real ( tfr ), intent ( out ) :: num !> Status of the evaluation logical :: stat character ( len = len ( raw )) :: inp integer :: i , j , err stat = toml_raw_verify_float ( raw ) if ( stat ) then inp = '' j = 0 do i = 1 , len ( raw ) if ( raw ( i : i ) == '_' ) cycle j = j + 1 inp ( j : j ) = raw ( i : i ) end do read ( inp , * , iostat = err ) num stat = err == 0 end if end function !> Attempt to convert TOML raw value to Fortran integer function toml_raw_to_integer ( raw , num ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> Integer value represented by raw value integer ( tfi ), intent ( out ) :: num !> Status of the evaluation logical :: stat character ( kind = tfc , len = len ( raw )) :: inp character ( len = 10 ) :: fmt logical :: minus integer :: i , j , err integer :: first stat = toml_raw_verify_integer ( raw ) if ( stat ) then minus = raw ( 1 : 1 ) == '-' inp = '' first = scan ( raw , 'xob' ) + 1 j = 0 do i = first , len ( raw ) if ( raw ( i : i ) == '_' ) cycle j = j + 1 inp ( j : j ) = raw ( i : i ) end do if ( first > 1 ) then select case ( raw ( first - 1 : first - 1 )) case ( 'x' ); write ( fmt , '(\"(z\",i0,\")\")' ) j case ( 'o' ); write ( fmt , '(\"(o\",i0,\")\")' ) j case ( 'b' ); write ( fmt , '(\"(b\",i0,\")\")' ) j end select read ( inp , fmt , iostat = err ) num if ( minus ) num = - num else read ( inp , * , iostat = err ) num end if stat = err == 0 end if end function toml_raw_to_integer !> Attempt to convert TOML raw value to Fortran logical function toml_raw_to_bool ( raw , bool ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> Logical value represented by raw value logical , intent ( out ) :: bool !> Status of the evaluation logical :: stat stat = toml_raw_verify_bool ( raw ) if ( stat ) then select case ( raw ) case ( 'true' ); bool = . true . case ( 'false' ); bool = . false . end select end if end function toml_raw_to_bool !> Attempt to convert TOML raw value to TOML datetime function toml_raw_to_timestamp ( raw , timestamp ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> TOML datetime value type ( toml_datetime ), intent ( out ) :: timestamp !> Status of the evaluation logical :: stat integer :: err , dot_pos , first stat = toml_raw_verify_timestamp ( raw ) first = 1 if ( toml_raw_verify_date ( raw )) then timestamp % date = toml_date () read ( raw ( 1 : 4 ), * , iostat = err ) timestamp % date % year stat = err == 0 read ( raw ( 6 : 7 ), * , iostat = err ) timestamp % date % month stat = stat . and . err == 0 read ( raw ( 9 : 10 ), * , iostat = err ) timestamp % date % day stat = stat . and . err == 0 if (. not . stat . or . len ( raw ) == 10 ) return first = 12 end if if ( toml_raw_verify_time ( raw ( first :))) then timestamp % time = toml_time () read ( raw ( first : first + 1 ), * , iostat = err ) timestamp % time % hour stat = err == 0 read ( raw ( first + 3 : first + 4 ), * , iostat = err ) timestamp % time % minute stat = stat . and . err == 0 read ( raw ( first + 6 : first + 7 ), * , iostat = err ) timestamp % time % second stat = stat . and . err == 0 if ( len ( raw ( first :)) > 8 ) then dot_pos = index ( raw , '.' ) if ( dot_pos > 0 ) then allocate ( timestamp % time % millisec , source = 0 ) read ( raw ( dot_pos + 1 : dot_pos + 3 ), * , iostat = err ) timestamp % time % millisec stat = stat . and . err == 0 end if dot_pos = verify ( raw ( first :), TOML_DIGITS // '.:' ) + first - 1 if ( dot_pos > first ) timestamp % time % zone = raw ( dot_pos :) end if end if end function toml_raw_to_timestamp logical function toml_raw_to_string ( raw , str ) result ( stat ) character ( kind = tfc , len =* ), intent ( in ) :: raw character ( kind = tfc , len = :), allocatable , intent ( out ) :: str character ( kind = tfc , len = :), allocatable :: tmp logical :: multiline logical :: verbatim stat = toml_raw_verify_string ( raw ) if ( stat ) then verbatim = raw ( 1 : 1 ) == TOML_SQUOTE multiline = verify ( raw ( 1 : 3 ), TOML_DQUOTE ) == 0 & & . or . verify ( raw ( 1 : 3 ), TOML_SQUOTE ) == 0 if ( multiline ) then tmp = raw ( 4 : len ( raw ) - 3 ) call toml_normalize_multiline ( tmp ) else tmp = raw ( 2 : len ( raw ) - 1 ) end if if (. not . verbatim ) call toml_normalize_string ( tmp ) call move_alloc ( tmp , str ) end if end function toml_raw_to_string subroutine toml_normalize_multiline ( str ) character ( kind = tfc , len = :), allocatable , intent ( inout ) :: str character ( kind = tfc , len = :), allocatable :: tmp integer :: i , j , bsl ! if there are no newlines, we are done here if ( scan ( str , TOML_NEWLINE ) == 0 ) return ! check for leading newlines i = verify ( str , TOML_NEWLINE ) ! for the case everything is newline, we will go with an empty string if ( i == 0 ) then str = '' return end if tmp = '' do while ( i < len ( str )) ! find next backslash character bsl = index ( str ( i :), '\\') - 1 if (bsl < 0) then tmp = tmp // str(i:) i = len(str) else j = verify(str(i+bsl+1:), TOML_WHITESPACE//TOML_NEWLINE) - 1 if (j < 0) then tmp = tmp // str(i:i+bsl) i = len(str) else if (j == 0) then tmp = tmp // str(i:i+bsl) i = i + bsl + 1 else tmp = tmp // str(i:i+bsl-1) i = i + bsl + j + 1 end if end if end do call move_alloc(tmp, str) end subroutine toml_normalize_multiline subroutine toml_normalize_string(str) character(kind=tfc, len=:), allocatable, intent(inout) :: str character(kind=tfc, len=:), allocatable :: tmp character :: ch integer :: i, ii logical :: escape integer, parameter :: x00 = int(z' 00 '), x08 = int(z' 08 '), x0b = int(z' 0 B '), & & x1f = int(z' 1 f '), x7f = int(z' 7 f ') escape = .false. tmp = '' do i = 1, len(str) ch = str(i:i) ii = ichar(ch) if (escape) then escape = .false. select case(ch) case(' b '); tmp = tmp // TOML_BACKSPACE case(' t '); tmp = tmp // TOML_TABULATOR case(' n '); tmp = tmp // TOML_NEWLINE case(' f '); tmp = tmp // TOML_FORMFEED case(' r '); tmp = tmp // TOML_CARRIAGE_RETURN case(' \" ', ' \\ '); tmp = tmp // ch case(' u '); tmp = tmp // ' \\ u ' ! FIXME case(' U '); tmp = tmp // ' \\ U ' ! FIXME end select else if (ch == ' \\' ) then escape = . true . else ! check for illegal control characters if (( x00 <= ii . and . ii <= x08 ) . or . & &( x0B <= ii . and . ii <= x1f ) . or . ii == x7f ) return tmp = tmp // ch end if end if end do call move_alloc ( tmp , str ) end subroutine toml_normalize_string end module tomlf_utils_convert","tags":"","loc":"sourcefile/convert.f90.html"},{"title":"value.f90 – TOML-Fortran","text":"Contents Modules tomlf_type_value Source Code value.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Class definitions for basic data types used for handling TOML module tomlf_type_value use tomlf_constants , only : tfc , TOML_BAREKEY use tomlf_utils , only : toml_escape_string implicit none private public :: toml_value , toml_visitor , toml_key !> Abstract base value for TOML data types type , abstract :: toml_value !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key contains !> Accept a visitor to transverse the data structure procedure :: accept !> Get escaped key to TOML value procedure :: get_key !> Compare raw key of TOML value to input key procedure :: match_key !> Release allocation hold by TOML value procedure ( destroy ), deferred :: destroy end type toml_value !> Abstract visitor for TOML values type , abstract :: toml_visitor contains !> Visitor visiting a TOML value procedure ( visit ), deferred :: visit end type toml_visitor !> Thin wrapper around the deferred-size character intrinisc type :: toml_key !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key end type toml_key abstract interface !> Accept a visitor to transverse the data structure recursive subroutine visit ( self , val ) import toml_value , toml_visitor !> Instance of the visitor class ( toml_visitor ), intent ( inout ) :: self !> Value to visit class ( toml_value ), intent ( inout ) :: val end subroutine visit !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) import toml_value !> Instance of the TOML value class ( toml_value ), intent ( inout ) :: self end subroutine destroy end interface contains !> Accept a visitor to transverse the data structure recursive subroutine accept ( self , visitor ) !> Instance of the TOML value class ( toml_value ), intent ( inout ) :: self !> Visitor for this value class ( toml_visitor ), intent ( inout ) :: visitor call visitor % visit ( self ) end subroutine accept !> Get escaped key to TOML value subroutine get_key ( self , key ) !> TOML value instance. class ( toml_value ), intent ( in ) :: self !> Contains valid TOML key on exit character ( kind = tfc , len = :), allocatable :: key if ( allocated ( self % key )) then if ( verify ( self % key , TOML_BAREKEY ) == 0 . and . len ( self % key ) > 0 ) then key = self % key else call toml_escape_string ( self % key , key ) end if end if end subroutine get_key !> Compare raw key of TOML value to input key pure function match_key ( self , key ) result ( match ) !> TOML value instance. class ( toml_value ), intent ( in ) :: self !> TOML raw key to compare to character ( kind = tfc , len =* ), intent ( in ) :: key logical :: match if ( allocated ( self % key )) then match = key == self % key else match = . false . end if end function match_key end module tomlf_type_value","tags":"","loc":"sourcefile/value.f90.html"},{"title":"table.f90 – TOML-Fortran","text":"Contents Modules tomlf_type_table Source Code table.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of the TOML table data type. !> !> Every TOML document contains at least one (root) table which holds key-value !> pairs, arrays and other tables. module tomlf_type_table use tomlf_constants , only : tfc use tomlf_error , only : toml_stat use tomlf_type_value , only : toml_value , toml_visitor , toml_key use tomlf_structure , only : toml_structure , new_structure implicit none private public :: toml_table , new_table , new !> TOML table type , extends ( toml_value ) :: toml_table !> Table was implictly created logical :: implicit = . false . !> Is an inline table and is therefore non-extendable logical :: inline = . false . !> Storage unit for TOML values of this table class ( toml_structure ), allocatable :: list contains !> Get the TOML value associated with the respective key procedure :: get !> Get list of all keys in this table procedure :: get_keys !> Check if key is already present in this table instance procedure :: has_key !> Append value to table (checks automatically for key) procedure :: push_back !> Delete TOML value at a given key procedure :: delete !> Release allocation hold by TOML table procedure :: destroy end type toml_table !> Create standard constructor interface toml_table module procedure :: new_table_func end interface toml_table !> Overloaded constructor for TOML values interface new module procedure :: new_table end interface contains !> Constructor to create a new TOML table and allocate the internal storage subroutine new_table ( self ) !> Instance of the TOML table type ( toml_table ), intent ( out ) :: self call new_structure ( self % list ) end subroutine new_table !> Default constructor for TOML table type function new_table_func () result ( self ) !> Instance of the TOML table type ( toml_table ) :: self call new_table ( self ) end function new_table_func !> Get the TOML value associated with the respective key subroutine get ( self , key , ptr ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the TOML value class ( toml_value ), pointer , intent ( out ) :: ptr call self % list % find ( key , ptr ) end subroutine get !> Get list of all keys in this table subroutine get_keys ( self , list ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) call self % list % get_keys ( list ) end subroutine get_keys !> Check if a key is present in the table function has_key ( self , key ) result ( found ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> TOML value is present in table logical :: found class ( toml_value ), pointer :: ptr call self % list % find ( key , ptr ) found = associated ( ptr ) end function has_key !> Push back a TOML value to the table subroutine push_back ( self , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> TOML value to append to table class ( toml_value ), allocatable , intent ( inout ) :: val !> Status of operation integer , intent ( out ) :: stat if (. not . allocated ( val )) then stat = toml_stat % fatal return end if if (. not . allocated ( val % key )) then stat = toml_stat % fatal return end if if ( self % has_key ( val % key )) then stat = toml_stat % duplicate_key return end if call self % list % push_back ( val ) stat = toml_stat % success end subroutine push_back !> Delete TOML value at a given key subroutine delete ( self , key ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key call self % list % delete ( key ) end subroutine delete !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % list )) then call self % list % destroy deallocate ( self % list ) end if end subroutine destroy end module tomlf_type_table","tags":"","loc":"sourcefile/table.f90~2.html"},{"title":"array.f90 – TOML-Fortran","text":"Contents Modules tomlf_type_array Source Code array.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of the TOML array data type. module tomlf_type_array use tomlf_error , only : toml_stat use tomlf_type_value , only : toml_value , toml_visitor use tomlf_structure , only : toml_ordered , new_ordered implicit none private public :: toml_array , new_array , new , len !> TOML array type , extends ( toml_value ) :: toml_array !> Is an inline array rather than an array of tables logical :: inline = . true . !> Storage unit for TOML values of this array class ( toml_ordered ), allocatable :: list contains !> Get the TOML value at a given index procedure :: get !> Append value to array procedure :: push_back !> Remove the first element from the array procedure :: shift !> Remove the last element from the array procedure :: pop !> Release allocation hold by TOML array procedure :: destroy end type toml_array !> Create standard constructor interface toml_array module procedure :: new_array_func end interface toml_array !> Overloaded constructor for TOML values interface new module procedure :: new_array end interface !> Overload len function interface len module procedure :: get_len end interface contains !> Constructor to create a new TOML array and allocate the internal storage subroutine new_array ( self ) !> Instance of the TOML array type ( toml_array ), intent ( out ) :: self call new_ordered ( self % list ) end subroutine new_array !> Default constructor for TOML array type function new_array_func () result ( self ) !> Instance of the TOML array type ( toml_array ) :: self call new_array ( self ) end function new_array_func !> Get number of TOML values in the array pure function get_len ( self ) result ( length ) !> Instance of the TOML array class ( toml_array ), intent ( in ) :: self !> Current length of the array integer :: length length = self % list % get_len () end function get_len !> Get the TOML value at the respective index subroutine get ( self , idx , ptr ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> Index to the TOML value integer , intent ( in ) :: idx !> Pointer to the TOML value class ( toml_value ), pointer , intent ( out ) :: ptr call self % list % get ( idx , ptr ) end subroutine get !> Push back a TOML value to the array subroutine push_back ( self , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to append to array class ( toml_value ), allocatable , intent ( inout ) :: val !> Status of operation integer , intent ( out ) :: stat if ( allocated ( val % key )) then stat = toml_stat % fatal return end if call self % list % push_back ( val ) stat = toml_stat % success end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val call self % list % shift ( val ) end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val call self % list % pop ( val ) end subroutine pop !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % list )) then call self % list % destroy deallocate ( self % list ) end if end subroutine destroy end module tomlf_type_array","tags":"","loc":"sourcefile/array.f90~2.html"},{"title":"keyval.f90 – TOML-Fortran","text":"Contents Modules tomlf_type_keyval Source Code keyval.f90 Source Code ! This file is part of toml-f. ! ! Copyright (C) 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> TOML key-value pair module tomlf_type_keyval use tomlf_constants , only : tfc use tomlf_type_value , only : toml_value , toml_visitor implicit none private public :: toml_keyval , new_keyval , new !> TOML key-value pair type , extends ( toml_value ) :: toml_keyval !> Raw content of the TOML value character ( kind = tfc , len = :), allocatable :: raw contains !> Release allocation hold by TOML key-value pair procedure :: destroy end type toml_keyval !> Overloaded constructor for TOML values interface new module procedure :: new_keyval end interface contains !> Constructor to create a new TOML key-value pair subroutine new_keyval ( self ) !> Instance of the TOML key-value pair type ( toml_keyval ), intent ( out ) :: self associate ( self => self ); end associate end subroutine new_keyval !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % raw )) then deallocate ( self % raw ) end if end subroutine destroy end module tomlf_type_keyval","tags":"","loc":"sourcefile/keyval.f90~2.html"},{"title":"tokenizer.f90 – TOML-Fortran","text":"Contents Modules tomlf_de_tokenizer Source Code tokenizer.f90 Source Code ! This file is part of toml-f. ! ! Copyright 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Definition of the TOML tokens and the possible states of the tokenizer !> !> The tokenizer implementation has to produce tokens from any input source !> and is usually only required for string tokens to provide an actual character !> representation. !> !> The tokenization is partly dependent on the context, as the dot is not in !> all states actually a token, also due to the rather complex syntax of !> table headers, whitespace is precious and has to be reported as token. !> !> Not required but usually helpful is the creation of a context, usually !> represented by the current line (or a chunk of lines for multiline strings), !> which can be passed to the error handler to create more detailed output. !> A tokenizer working with the complete TOML document as character sequence !> can easily create the context, while it might be incomplete or missing in !> case of a stream processing. module tomlf_de_tokenizer use tomlf_constants , only : toml_escape , tfc , TOML_BAREKEY , toml_type use tomlf_error , only : toml_stat , toml_error , toml_context , & & syntax_error , duplicate_key_error , vendor_error use tomlf_utils use tomlf_type , only : toml_value , toml_key , toml_table , toml_array , & & toml_keyval , new_table , add_array , add_table , add_keyval , len implicit none private public :: toml_tokenizer , toml_token , toml_tokentype type :: enum_tokentype integer :: invalid = 0 integer :: dot = 1 integer :: comma = 2 integer :: equal = 3 integer :: lbrace = 4 integer :: rbrace = 5 integer :: whitespace = 6 integer :: newline = 7 integer :: lbracket = 8 integer :: rbracket = 9 integer :: string = 10 integer :: comment = - 1 end type enum_tokentype type ( enum_tokentype ), parameter :: toml_tokentype = enum_tokentype () !> Basic TOML token, produced by a TOML tokenizer type :: toml_token !> Actual tokentype integer :: tok = toml_tokentype % invalid !> Character representation of the token character ( len = :), pointer :: ptr => null () !> Length of the token at ptr integer :: len = 0 end type toml_token !> Abstract TOML tokenizer type , abstract :: toml_tokenizer !> Signals if the tokenizer has finished (EOF has been reached) logical :: finished = . false . !> Current token type ( toml_token ) :: tok !> Root table type ( toml_table ), allocatable :: root !> Pointer to the current table while transversing a table path type ( toml_table ), pointer :: current => null () !> Current line (for error handling) type ( toml_context ) :: line !> Error buffer, if allocated an error has occurred type ( toml_error ), allocatable :: error contains !> Entry point for parsing the TOML document, creates the root table procedure :: parse => parse_root !> Parse a TOML table or array of tables header procedure , private :: parse_select !> Parse an inline TOML array procedure , private :: parse_array !> Parse an inline TOML table procedure , private :: parse_table !> Parse a key-value pair procedure , private :: parse_keyval !> Advance tokenizer procedure , private :: next !> Return next token procedure ( next_token ), deferred :: next_token end type toml_tokenizer abstract interface !> Return next token subroutine next_token ( de , dot_is_token ) import :: toml_tokenizer !> Instance of the tokenizer class ( toml_tokenizer ), intent ( inout ) :: de !> Dot should be handled as token logical , intent ( in ) :: dot_is_token end subroutine next_token end interface contains !> Entry point for parsing the TOML document, creates the root table subroutine parse_root ( de ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de allocate ( de % root ) call new_table ( de % root ) de % current => de % root do while (. not . de % finished ) select case ( de % tok % tok ) case default call syntax_error ( de % error , de % line , \"syntax error\" ) exit case ( toml_tokentype % newline ) call de % next (. true .) case ( toml_tokentype % string ) call de % parse_keyval ( de % current ) if ( allocated ( de % error )) exit if ( de % tok % tok /= toml_tokentype % newline ) then call syntax_error ( de % error , de % line , \"extra characters after value present\" ) exit end if case ( toml_tokentype % lbracket ) call parse_select ( de ) if ( allocated ( de % error )) exit end select end do end subroutine parse_root !> Parse a key-value pair recursive subroutine parse_keyval ( de , table ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de !> Current TOML table type ( toml_table ), intent ( inout ) :: table type ( toml_token ) :: key type ( toml_keyval ), pointer :: vptr type ( toml_array ), pointer :: aptr type ( toml_table ), pointer :: tptr character ( kind = tfc , len = :), allocatable :: new_key , this_key key = de % tok !@:ASSERT(de%tok%tok == STRING) call de % next (. true .) if ( de % tok % tok == toml_tokentype % dot ) then ! create new key from token call key_from_token ( this_key , key ) call get_table ( table , this_key , tptr ) deallocate ( this_key ) if ( tptr % inline ) then call syntax_error ( de % error , de % line , \"Cannot add keys to inline tables\" ) return end if call de % next (. true .) if ( de % tok % tok == toml_tokentype % string ) then call de % parse_keyval ( tptr ) else call syntax_error ( de % error , de % line , \"invalid key\" ) end if return end if if ( de % tok % tok /= toml_tokentype % equal ) then call syntax_error ( de % error , de % line , \"missing =\" ) return end if call de % next (. false .) if ( allocated ( de % error )) return ! create new key from token call key_from_token ( new_key , key ) if (. not . allocated ( new_key )) then call syntax_error ( de % error , de % line , \"invalid key\" ) return end if select case ( de % tok % tok ) case default call syntax_error ( de % error , de % line , \"unexpected token\" ) return case ( toml_tokentype % string ) ! key = \"value\" call add_keyval ( table , new_key , vptr ) if (. not . associated ( vptr )) then call duplicate_key_error ( de % error , de % line , new_key ) return end if vptr % raw = de % tok % ptr (: de % tok % len ) if ( toml_get_value_type ( vptr % raw ) == toml_type % invalid ) then call syntax_error ( de % error , de % line , \"unknown value type\" ) return end if call de % next (. true .) if ( allocated ( de % error )) return case ( toml_tokentype % lbracket ) ! key = [ array ] call add_array ( table , new_key , aptr ) if (. not . associated ( aptr )) then call duplicate_key_error ( de % error , de % line , new_key ) return end if aptr % inline = . true . call de % parse_array ( aptr ) if ( allocated ( de % error )) return case ( toml_tokentype % lbrace ) ! key = { table } call add_table ( table , new_key , tptr ) if (. not . associated ( tptr )) then call duplicate_key_error ( de % error , de % line , new_key ) return end if call de % parse_table ( tptr ) tptr % inline = . true . if ( allocated ( de % error )) return end select end subroutine parse_keyval !> Parse a TOML table or array of tables header subroutine parse_select ( de ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de type ( toml_array ), pointer :: array type ( toml_table ), pointer :: table class ( toml_value ), pointer :: ptr character ( kind = tfc , len = :), allocatable :: key logical :: llb integer , parameter :: initial_size = 8 integer :: top type ( toml_key ), allocatable :: stack (:) nullify ( table ) !@:assert(de%tok%tok == toml_tokentype%lbracket) call de % next (. true ., whitespace_is_precious = . true .) llb = de % tok % tok == toml_tokentype % lbracket if ( llb . or . de % tok % tok == toml_tokentype % whitespace ) then call de % next (. true .) end if call fill_stack ( de , top , stack ) if ( allocated ( de % error )) return ! remove topmost element from path call move_alloc ( stack ( top )% key , key ) top = top - 1 call walk_stack ( de , top , stack ) if ( allocated ( de % error )) return if ( llb ) then ! [[key.key.top]] call de % current % get ( key , ptr ) if ( associated ( ptr )) then select type ( ptr ) type is ( toml_array ) array => ptr class default call duplicate_key_error ( de % error , de % line , key ) return end select else call add_array ( de % current , key , array ) array % inline = . false . end if if ( array % inline ) then call syntax_error ( de % error , de % line , \"Cannot use inline array in array of tables\" ) return end if call add_table ( array , table ) else ! [key.key.top] call de % current % get ( key , ptr ) if ( associated ( ptr )) then select type ( ptr ) type is ( toml_table ) if ( ptr % implicit ) then table => ptr else call duplicate_key_error ( de % error , de % line , key ) return end if class default call duplicate_key_error ( de % error , de % line , key ) return end select else call add_table ( de % current , key , table ) end if end if if (. not . associated ( table )) then call syntax_error ( de % error , de % line , \"Cannot add table in this context\" ) return end if de % current => table if ( de % tok % tok /= toml_tokentype % rbracket ) then call syntax_error ( de % error , de % line , \"expects ]\" ) return end if call de % next (. true ., whitespace_is_precious = llb ) if ( llb ) then if ( de % tok % tok /= toml_tokentype % rbracket ) then call syntax_error ( de % error , de % line , \"expects ]]\" ) return end if call de % next (. true .) end if if ( de % tok % tok /= toml_tokentype % newline ) then call syntax_error ( de % error , de % line , \"extra chars after ] or ]]\" ) return end if contains !> Fill the stack with tokens subroutine fill_stack ( de , top , stack ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de !> Depth of the table key stack integer , intent ( out ) :: top !> Stack of all keys in the table header type ( toml_key ), allocatable , intent ( out ) :: stack (:) top = 0 allocate ( stack ( initial_size )) do if ( top >= size ( stack )) then call resize ( stack ) end if if ( de % tok % tok /= toml_tokentype % string ) then call syntax_error ( de % error , de % line , \"invalid or missing key\" ) return end if top = top + 1 call key_from_token ( stack ( top )% key , de % tok ) if (. not . allocated ( stack ( top )% key )) then call syntax_error ( de % error , de % line , \"invalid key\" ) return end if call de % next (. true .) if ( de % tok % tok == toml_tokentype % rbracket ) exit if ( de % tok % tok /= toml_tokentype % dot ) then call syntax_error ( de % error , de % line , \"invalid key\" ) return end if call de % next (. true .) end do if ( top <= 0 ) then call syntax_error ( de % error , de % line , \"empty table selector\" ) end if end subroutine fill_stack !> Walk the key stack to fetch the correct table, create implicit tables as !  necessary subroutine walk_stack ( de , top , stack ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de !> Depth of the table key stack integer , intent ( in ) :: top !> Stack of all keys in the table header type ( toml_key ), intent ( in ), target :: stack (:) type ( toml_table ), pointer :: table , tmp_tbl character ( kind = tfc , len = :), pointer :: key class ( toml_value ), pointer :: ptr , tmp integer :: i table => de % root do i = 1 , top key => stack ( i )% key if (. not . table % has_key ( key )) then call add_table ( table , key , tmp_tbl ) if ( associated ( tmp_tbl )) then tmp_tbl % implicit = . true . end if end if call table % get ( key , ptr ) select type ( ptr ) type is ( toml_table ) table => ptr type is ( toml_array ) call ptr % get ( len ( ptr ), tmp ) select type ( tmp ) type is ( toml_table ) table => tmp class default call vendor_error ( de % error , de % line ) return end select class default call duplicate_key_error ( de % error , de % line , key ) return end select end do de % current => table end subroutine walk_stack !> Change size of the stack subroutine resize ( stack , n ) !> Stack of keys to be resized type ( toml_key ), allocatable , intent ( inout ) :: stack (:) !> New size of the stack integer , intent ( in ), optional :: n type ( toml_key ), allocatable :: tmp (:) integer :: m if ( present ( n )) then m = n else if ( allocated ( stack )) then m = size ( stack ) m = m + m / 2 + 1 else m = initial_size end if end if if ( allocated ( stack )) then call move_alloc ( stack , tmp ) allocate ( stack ( m )) m = min ( size ( tmp ), m ) stack (: m ) = tmp (: m ) deallocate ( tmp ) else allocate ( stack ( m )) end if end subroutine resize end subroutine parse_select !> Parse an inline TOML array recursive subroutine parse_array ( de , array ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de !> TOML array to be filled type ( toml_array ), intent ( inout ) :: array type ( toml_table ), pointer :: tbl type ( toml_keyval ), pointer :: val type ( toml_array ), pointer :: arr !@:assert(de%tok%tok == toml_tokentype%lbracket) call de % next (. false .) do do while ( de % tok % tok == toml_tokentype % newline ) call de % next (. false .) end do if ( de % tok % tok == toml_tokentype % rbracket ) then exit end if select case ( de % tok % tok ) case default call syntax_error ( de % error , de % line , \"unexpected token\" ) return case ( toml_tokentype % string ) ! [ value, value ... ] call add_keyval ( array , val ) val % raw = de % tok % ptr (: de % tok % len ) call de % next (. false .) case ( toml_tokentype % lbracket ) ! [ [array], [array] ...] call add_array ( array , arr ) arr % inline = . true . call de % parse_array ( arr ) if ( allocated ( de % error )) return case ( toml_tokentype % lbrace ) ! [ {table}, {table} ... ] call add_table ( array , tbl ) tbl % inline = . true . call de % parse_table ( tbl ) if ( allocated ( de % error )) return end select do while ( de % tok % tok == toml_tokentype % newline ) call de % next (. false .) end do if ( de % tok % tok == toml_tokentype % comma ) then call de % next (. false .) cycle end if exit end do if ( de % tok % tok /= toml_tokentype % rbracket ) then call syntax_error ( de % error , de % line , \"expects ]\" ) return end if call de % next (. true .) end subroutine parse_array !> Parse an inline TOML table recursive subroutine parse_table ( de , table ) !> Instance of the TOML deserializer class ( toml_tokenizer ), intent ( inout ), target :: de !> TOML table to be filled type ( toml_table ), intent ( inout ) :: table !@:ASSERT(de%tok%tok == LBRACE) call de % next (. true .) do if ( de % tok % tok == toml_tokentype % newline ) then call syntax_error ( de % error , de % line , \"newline not allowed in inline table\" ) return end if if ( de % tok % tok == toml_tokentype % rbrace ) exit if ( de % tok % tok /= toml_tokentype % string ) then call syntax_error ( de % error , de % line , \"expects string value\" ) return end if call de % parse_keyval ( table ) if ( allocated ( de % error )) exit if ( de % tok % tok == toml_tokentype % string ) then call syntax_error ( de % error , de % line , \"newline not allowed in inline table\" ) return end if if ( de % tok % tok == toml_tokentype % comma ) then call de % next (. true .) cycle end if exit end do if ( de % tok % tok /= toml_tokentype % rbrace ) then call syntax_error ( de % error , de % line , \"expects }\" ) return end if call de % next (. true .) end subroutine parse_table !> Generate a key subroutine key_from_token ( key , tok ) !> TOML raw key character ( kind = tfc , len = :), allocatable , intent ( out ) :: key !> String token containing the possible key type ( toml_token ), intent ( in ) :: tok if ( toml_raw_to_string ( tok % ptr (: tok % len ), key )) then if ( index ( key , toml_escape % newline ) > 0 ) deallocate ( key ) else key = tok % ptr (: tok % len ) if ( verify ( key , TOML_BAREKEY ) > 0 ) deallocate ( key ) end if end subroutine key_from_token !> Try to retrieve TOML table with key or create it subroutine get_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then select type ( tmp ) type is ( toml_table ) ptr => tmp if ( present ( stat )) stat = toml_stat % success class default if ( present ( stat )) stat = toml_stat % fatal end select else call add_table ( table , key , ptr , stat ) end if end subroutine get_table !> Return next token subroutine next ( de , dot_is_token , whitespace_is_precious ) !> Instance of the tokenizer class ( toml_tokenizer ), intent ( inout ) :: de !> Dot should be handled as token logical , intent ( in ) :: dot_is_token !> Whitespace tokens should be skipped logical , intent ( in ), optional :: whitespace_is_precious logical :: skip_whitespace if ( present ( whitespace_is_precious )) then skip_whitespace = . not . whitespace_is_precious else skip_whitespace = . true . end if call de % next_token ( dot_is_token ) if ( skip_whitespace ) then do while ( de % tok % tok == toml_tokentype % whitespace ) if ( allocated ( de % error )) exit call de % next_token ( dot_is_token ) end do end if end subroutine next end module tomlf_de_tokenizer","tags":"","loc":"sourcefile/tokenizer.f90.html"},{"title":"character.f90 – TOML-Fortran","text":"Contents Modules tomlf_de_character Source Code character.f90 Source Code ! This file is part of toml-f. ! ! Copyright 2019-2020 Sebastian Ehlert ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a tokenizer for character variables module tomlf_de_character use tomlf_constants use tomlf_error , only : syntax_error use tomlf_de_tokenizer use tomlf_utils implicit none private public :: toml_character_tokenizer , new_character_tokenizer , new !> Tokenizer for a sequence of characters type , extends ( toml_tokenizer ) :: toml_character_tokenizer !> Link to the input configuration. character ( len = :), pointer :: conf contains !> Return next token procedure :: next_token end type toml_character_tokenizer interface new module procedure :: new_character_tokenizer end interface new contains !> Constructor for the deserializer implementation. subroutine new_character_tokenizer ( de , conf ) type ( toml_character_tokenizer ), intent ( out ) :: de character ( len =* ), intent ( in ), target :: conf !> connect deserializer to configuration de % conf => conf de % line % ptr => conf de % line % num = 1 !> first token is an artifical newline de % tok = new_token ( toml_tokentype % newline , de % conf , 0 ) end subroutine new_character_tokenizer !> Return next token subroutine next_token ( de , dot_is_token ) !> Instance of the tokenizer class ( toml_character_tokenizer ), intent ( inout ) :: de !> Dot should be handled as token logical , intent ( in ) :: dot_is_token character ( len = :), pointer :: ptr integer :: i , skip if ( de % finished ) return ptr => de % tok % ptr !> consume token do i = 1 , de % tok % len de % line % pos = de % line % pos + 1 if ( ptr ( i : i ) == TOML_NEWLINE ) then de % line % ptr => ptr ( min ( i + 1 , len ( ptr )):) de % line % num = de % line % num + 1 de % line % pos = 1 end if end do ptr => ptr ( de % tok % len + 1 :) !> make next token do while ( len ( ptr ) > 0 ) select case ( ptr ( 1 : 1 )) case ( '#' ) i = index ( ptr , TOML_NEWLINE ) if ( i > 0 ) then ptr => ptr ( i :) cycle end if exit case ( '.' ) if ( dot_is_token ) then de % tok = new_token ( toml_tokentype % dot , ptr , 1 ) return end if case ( ',' ); de % tok = new_token ( toml_tokentype % comma , ptr , 1 ); return case ( '=' ); de % tok = new_token ( toml_tokentype % equal , ptr , 1 ); return case ( '{' ); de % tok = new_token ( toml_tokentype % lbrace , ptr , 1 ); return case ( '}' ); de % tok = new_token ( toml_tokentype % rbrace , ptr , 1 ); return case ( '[' ); de % tok = new_token ( toml_tokentype % lbracket , ptr , 1 ); return case ( ']' ); de % tok = new_token ( toml_tokentype % rbracket , ptr , 1 ); return case ( TOML_NEWLINE ); de % tok = new_token ( toml_tokentype % newline , ptr , 1 ); return case ( ' ' , char ( 9 )); skip = verify ( ptr , TOML_WHITESPACE ) - 1 de % tok = new_token ( toml_tokentype % whitespace , ptr , skip ) return end select call scan_string ( de , ptr , dot_is_token ) return end do !> return with EOF token de % finished = . true . de % tok = new_token ( toml_tokentype % newline , ptr ( 1 : 0 ), 0 ) contains subroutine scan_string ( de , ptr , dot_is_token ) class ( toml_character_tokenizer ), intent ( inout ) :: de character ( len = :), pointer , intent ( inout ) :: ptr logical , intent ( in ) :: dot_is_token character ( len = :), pointer :: orig integer :: i , skip integer :: hexreq integer :: qcount logical :: escape orig => ptr if ( len ( ptr ) >= 6 ) then if ( ptr ( 1 : 3 ) == repeat ( TOML_SQUOTE , 3 )) then ptr => ptr ( 4 :) i = index ( ptr , repeat ( TOML_SQUOTE , 3 )) if ( i == 0 ) then call syntax_error ( de % error , de % line , \"unterminated triple-s-quote\" ) return end if de % tok = new_token ( toml_tokentype % string , orig , i + 5 ) return end if if ( ptr ( 1 : 3 ) == repeat ( TOML_DQUOTE , 3 )) then ptr => ptr ( 4 :) escape = . false . hexreq = 0 qcount = 0 do i = 1 , len ( ptr ) if ( escape ) then escape = . false . if ( ptr ( i : i ) == 'u' ) then hexreq = 4 cycle end if if ( ptr ( i : i ) == 'U' ) then hexreq = 8 cycle end if if ( verify ( ptr ( i : i ), 'btnfr\"\\') == 0) cycle ! allow for line ending backslash skip = verify(ptr(i:), TOML_WHITESPACE)-1 if (ptr(i+skip:i+skip) == TOML_NEWLINE) cycle call syntax_error(de%error, de%line, \"bad escape char\") return end if if (hexreq > 0) then hexreq = hexreq - 1 if (verify(ptr(i:i), TOML_HEXDIGITS) == 0) cycle call syntax_error(de%error, de%line, \"expect hex char\") return end if if (ptr(i:i) == TOML_DQUOTE) then if (qcount < 5) then qcount = qcount + 1 else call syntax_error(de%error, de%line, \"too many quotation marks\") return end if else if (qcount >= 3) then ptr => ptr(i:) exit end if qcount = 0 end if if (ptr(i:i) == ' \\ ') then escape = .true. cycle end if end do if (qcount < 3) then call syntax_error(de%error, de%line, \"unterminated triple-quote\") return end if de%tok = new_token(toml_tokentype%string, orig, len(orig)-len(ptr)) return end if end if if (ptr(1:1) == TOML_SQUOTE) then ptr => ptr(2:) i = index(ptr, TOML_NEWLINE) if (i == 0) i = len(ptr) i = index(ptr(:i), TOML_SQUOTE) if (i == 0) then call syntax_error(de%error, de%line, \"unterminated s-quote\") return end if de%tok = new_token(toml_tokentype%string, orig, i+1) return end if if (ptr(1:1) == TOML_DQUOTE) then ptr => ptr(2:) escape = .false. hexreq = 0 do i = 1, len(ptr) if (escape) then escape = .false. if (ptr(i:i) == ' u ') then hexreq = 4 cycle end if if (ptr(i:i) == ' U ') then hexreq = 8 cycle end if if (verify(ptr(i:i), ' btnfr \"\\') == 0) cycle call syntax_error(de%error, de%line, \" bad escape char \") return end if if (hexreq > 0) then hexreq = hexreq - 1 if (verify(ptr(i:i), TOML_HEXDIGITS) == 0) cycle call syntax_error(de%error, de%line, \" expect hex char \") return end if if (ptr(i:i) == '\\') then escape = .true. cycle end if if (ptr(i:i) == TOML_NEWLINE) then ptr => ptr(i:) exit end if if (ptr(i:i) == TOML_DQUOTE) then ptr => ptr(i:) exit end if end do if (ptr(1:1) /= TOML_DQUOTE) then call syntax_error(de%error, de%line, \" expect hex char \" ) return end if de % tok = new_token ( toml_tokentype % string , orig , len ( orig ) - len ( ptr ) + 1 ) return end if if ( toml_raw_verify_date ( ptr ) . or . toml_raw_verify_time ( ptr )) then i = verify ( ptr , TOML_TIMESTAMP ) - 1 if ( i < 0 ) i = len ( ptr ) de % tok = new_token ( toml_tokentype % string , orig , i ) return end if do i = 1 , len ( ptr ) if ( ptr ( i : i ) == '.' . and . dot_is_token ) then ptr => ptr ( i :) exit end if if ( verify ( ptr ( i : i ), TOML_LITERALS ) == 0 ) cycle ptr => ptr ( i :) exit end do de % tok = new_token ( toml_tokentype % string , orig , len ( orig ) - len ( ptr )) end subroutine scan_string end subroutine next_token !> custom constructor to get pointer assignment right type ( toml_token ) function new_token ( tok , ptr , len ) integer , intent ( in ) :: tok character ( len = :), pointer , intent ( in ) :: ptr integer , intent ( in ) :: len new_token % tok = tok new_token % ptr => ptr new_token % len = len end function new_token end module tomlf_de_character","tags":"","loc":"sourcefile/character.f90.html"},{"title":"toml_date – TOML-Fortran ","text":"type, public :: toml_date TOML date value (YYYY-MM-DD) Contents Variables day month year Type-Bound Procedures assignment(=) to_string Components Type Visibility Attributes Name Initial integer, public :: day = 0 integer, public :: month = 0 integer, public :: year = 0 Type-Bound Procedures generic, public :: assignment(=) => to_string private subroutine date_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_date ), intent(in) :: rhs procedure, public, pass(rhs) :: to_string => date_to_string private subroutine date_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_date ), intent(in) :: rhs","tags":"","loc":"type/toml_date.html"},{"title":"toml_datetime – TOML-Fortran ","text":"type, public :: toml_datetime TOML datatime value type Contents Variables date time Type-Bound Procedures assignment(=) to_string Components Type Visibility Attributes Name Initial type( toml_date ), public, allocatable :: date type( toml_time ), public, allocatable :: time Type-Bound Procedures generic, public :: assignment(=) => to_string private subroutine datetime_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_datetime ), intent(in) :: rhs procedure, public, pass(rhs) :: to_string => datetime_to_string private subroutine datetime_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_datetime ), intent(in) :: rhs","tags":"","loc":"type/toml_datetime.html"},{"title":"toml_time – TOML-Fortran ","text":"type, public :: toml_time TOML time value (HH:MM:SS.sssssZ…) Contents Variables hour millisec minute second zone Type-Bound Procedures assignment(=) to_string Components Type Visibility Attributes Name Initial integer, public :: hour = 0 integer, public, allocatable :: millisec integer, public :: minute = 0 integer, public :: second = 0 character(len=:), public, allocatable :: zone Type-Bound Procedures generic, public :: assignment(=) => to_string private subroutine time_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_time ), intent(in) :: rhs procedure, public, pass(rhs) :: to_string => time_to_string private subroutine time_to_string(lhs, rhs) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=:), intent(out), allocatable :: lhs class( toml_time ), intent(in) :: rhs","tags":"","loc":"type/toml_time.html"},{"title":"toml_context – TOML-Fortran ","text":"type, public :: toml_context Context for error message (usually a line in a TOML document) Contents Variables num pos ptr Source Code toml_context Components Type Visibility Attributes Name Initial integer, public :: num = 0 Current internal count integer, public :: pos = 0 Current internal position character(kind=tfc,len=:), public, pointer :: ptr => null() Current internal location on the string buffer Source Code type :: toml_context !> Current internal position integer :: pos = 0 !> Current internal count integer :: num = 0 !> Current internal location on the string buffer character ( kind = tfc , len = :), pointer :: ptr => null () end type toml_context","tags":"","loc":"type/toml_context.html"},{"title":"toml_error – TOML-Fortran ","text":"type, public :: toml_error Error message produced by TOML-Fortran Contents Variables message stat Source Code toml_error Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: message Payload of the error integer, public :: stat = toml_stat%fatal Error code Source Code type :: toml_error !> Error code integer :: stat = toml_stat % fatal !> Payload of the error character ( kind = tfc , len = :), allocatable :: message end type toml_error","tags":"","loc":"type/toml_error.html"},{"title":"toml_serializer – TOML-Fortran ","text":"type, public, extends( toml_visitor ) :: toml_serializer TOML serializer to produduce a TOML document from a datastructure Contents Variables unit Constructor toml_serializer Type-Bound Procedures visit Source Code toml_serializer Components Type Visibility Attributes Name Initial integer, public :: unit = tfout Unit for output Constructor public interface toml_serializer Create standard constructor private function new_serializer_func(unit) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: unit Unit for IO Return Value type( toml_serializer ) Instance of the TOML serializer Type-Bound Procedures procedure, public :: visit Visit a TOML value private subroutine visit(self, val) Visit a TOML value Arguments Type Intent Optional Attributes Name class( toml_serializer ), intent(inout) :: self Instance of the TOML serializer class( toml_value ), intent(inout) :: val TOML value to visit Source Code type , extends ( toml_visitor ) :: toml_serializer !> Unit for output integer :: unit = tfout !> Special mode for printing array of tables logical , private :: array_of_tables = . false . !> Special mode for printing inline arrays logical , private :: inline_array = . false . !> Top of the key stack integer , private :: top = 0 !> Key stack to create table headers type ( toml_key ), allocatable , private :: stack (:) contains !> Visit a TOML value procedure :: visit end type toml_serializer","tags":"","loc":"type/toml_serializer.html"},{"title":"toml_ordered – TOML-Fortran ","text":"type, public, abstract, extends( toml_structure ) :: toml_ordered Ordered data structure, allows iterations Contents Type-Bound Procedures delete destroy find get get_keys get_len pop push_back shift Source Code toml_ordered Type-Bound Procedures procedure(delete), public, deferred :: delete Delete TOML value at a given key subroutine delete(self, key) Prototype Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value procedure(destroy), public, deferred :: destroy Destroy the data structure subroutine destroy(self) Prototype Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure procedure(find), public, deferred :: find Find a TOML value based on its key subroutine find(self, key, ptr) Prototype Find a TOML value based on its key Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given key procedure(get), public, deferred :: get Get TOML value at a given index subroutine get(self, idx, ptr) Prototype Get TOML value at a given index Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(inout), target :: self Instance of the structure integer, intent(in) :: idx Position in the ordered structure class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given index procedure(get_keys), public, deferred :: get_keys Get list of all keys in the structure subroutine get_keys(self, list) Prototype Get list of all keys in the structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure(get_len), public, deferred :: get_len Get number of TOML values in the structure pure function get_len(self) result(length) Prototype Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(in), target :: self Instance of the structure Return Value integer Current length of the ordered structure procedure(pop), public, deferred :: pop Remove the last element from the structure subroutine pop(self, val) Prototype Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure subroutine push_back(self, val) Prototype Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored procedure(shift), public, deferred :: shift Remove the first element from the structure subroutine shift(self, val) Prototype Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , abstract , extends ( toml_structure ) :: toml_ordered contains !> Get number of TOML values in the structure procedure ( get_len ), deferred :: get_len !> Remove the first element from the structure procedure ( shift ), deferred :: shift !> Remove the last element from the structure procedure ( pop ), deferred :: pop !> Get TOML value at a given index procedure ( get ), deferred :: get end type toml_ordered","tags":"","loc":"type/toml_ordered.html"},{"title":"toml_structure – TOML-Fortran ","text":"type, public, abstract :: toml_structure Abstract data structure Contents Type-Bound Procedures delete destroy find get_keys push_back Source Code toml_structure Type-Bound Procedures procedure(delete), public, deferred :: delete Delete TOML value at a given key subroutine delete(self, key) Prototype Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value procedure(destroy), public, deferred :: destroy Destroy the data structure subroutine destroy(self) Prototype Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure procedure(find), public, deferred :: find Find a TOML value based on its key subroutine find(self, key, ptr) Prototype Find a TOML value based on its key Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given key procedure(get_keys), public, deferred :: get_keys Get list of all keys in the structure subroutine get_keys(self, list) Prototype Get list of all keys in the structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure subroutine push_back(self, val) Prototype Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored Source Code type , abstract :: toml_structure contains !> Find a TOML value based on its key procedure ( find ), deferred :: find !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Get list of all keys in the structure procedure ( get_keys ), deferred :: get_keys !> Delete TOML value at a given key procedure ( delete ), deferred :: delete !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_structure","tags":"","loc":"type/toml_structure.html"},{"title":"toml_vector – TOML-Fortran ","text":"type, public, extends( toml_ordered ) :: toml_vector Stores TOML values in a list of pointers Contents Variables lst n Type-Bound Procedures delete destroy find get get_keys get_len pop push_back shift Source Code toml_vector Components Type Visibility Attributes Name Initial type(toml_node), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: delete Delete TOML value at a given key private subroutine delete(self, key) Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value procedure, public :: destroy Destroy the data structure private subroutine destroy(self) Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure procedure, public :: find Find a TOML value based on its key private subroutine find(self, key, ptr) Find a TOML value based on its key Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure character(kind=tfc,len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given key procedure, public :: get Get TOML value at a given index private subroutine get(self, idx, ptr) Get TOML value at a given index Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure integer, intent(in) :: idx Position in the ordered structure class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given index procedure, public :: get_keys Get list of all keys in the structure private subroutine get_keys(self, list) Get list of all keys in the structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure, public :: get_len Get number of TOML values in the structure private pure function get_len(self) result(length) Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(in), target :: self Instance of the structure Return Value integer Current length of the ordered structure procedure, public :: pop Remove the last element from the structure private subroutine pop(self, val) Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure, public :: push_back Push back a TOML value to the structure private subroutine push_back(self, val) Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored procedure, public :: shift Remove the first element from the structure private subroutine shift(self, val) Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_vector ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , extends ( toml_ordered ) :: toml_vector !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get number of TOML values in the structure procedure :: get_len !> Find a TOML value based on its key procedure :: find !> Get TOML value at a given index procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove the first element from the structure procedure :: shift !> Remove the last element from the structure procedure :: pop !> Get list of all keys in the structure procedure :: get_keys !> Delete TOML value at a given key procedure :: delete !> Destroy the data structure procedure :: destroy end type toml_vector","tags":"","loc":"type/toml_vector.html"},{"title":"toml_key – TOML-Fortran ","text":"type, public :: toml_key Thin wrapper around the deferred-size character intrinisc Contents Variables key Source Code toml_key Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value Source Code type :: toml_key !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key end type toml_key","tags":"","loc":"type/toml_key.html"},{"title":"toml_value – TOML-Fortran ","text":"type, public, abstract :: toml_value Abstract base value for TOML data types Contents Variables key Type-Bound Procedures accept destroy get_key match_key Source Code toml_value Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure(destroy), public, deferred :: destroy Release allocation hold by TOML value subroutine destroy(self) Prototype Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value procedure, public :: get_key Get escaped key to TOML value private subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=*), intent(in) :: key TOML raw key to compare to Return Value logical Source Code type , abstract :: toml_value !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key contains !> Accept a visitor to transverse the data structure procedure :: accept !> Get escaped key to TOML value procedure :: get_key !> Compare raw key of TOML value to input key procedure :: match_key !> Release allocation hold by TOML value procedure ( destroy ), deferred :: destroy end type toml_value","tags":"","loc":"type/toml_value.html"},{"title":"toml_visitor – TOML-Fortran ","text":"type, public, abstract :: toml_visitor Abstract visitor for TOML values Contents Type-Bound Procedures visit Source Code toml_visitor Type-Bound Procedures procedure(visit), public, deferred :: visit Visitor visiting a TOML value recursive subroutine visit(self, val) Prototype Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_visitor ), intent(inout) :: self Instance of the visitor class( toml_value ), intent(inout) :: val Value to visit Source Code type , abstract :: toml_visitor contains !> Visitor visiting a TOML value procedure ( visit ), deferred :: visit end type toml_visitor","tags":"","loc":"type/toml_visitor.html"},{"title":"toml_table – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_table TOML table Contents Variables implicit inline key list Constructor toml_table Type-Bound Procedures accept delete destroy get get_key get_keys has_key match_key push_back Source Code toml_table Components Type Visibility Attributes Name Initial logical, public :: implicit = .false. Table was implictly created logical, public :: inline = .false. Is an inline table and is therefore non-extendable character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value class( toml_structure ), public, allocatable :: list Storage unit for TOML values of this table Constructor public interface toml_table Create standard constructor private function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: delete Delete TOML value at a given key private subroutine delete(self, key) Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key to the TOML value procedure, public :: destroy Release allocation hold by TOML table private subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table procedure, public :: get Get the TOML value associated with the respective key private subroutine get(self, key, ptr) Get the TOML value associated with the respective key Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the TOML value procedure, public :: get_key Get escaped key to TOML value private subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: get_keys Get list of all keys in this table private subroutine get_keys(self, list) Get list of all keys in this table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure, public :: has_key Check if key is already present in this table instance private function has_key(self, key) result(found) Check if a key is present in the table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key to the TOML value Return Value logical TOML value is present in table procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=*), intent(in) :: key TOML raw key to compare to Return Value logical procedure, public :: push_back Append value to table (checks automatically for key) private subroutine push_back(self, val, stat) Push back a TOML value to the table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table class( toml_value ), intent(inout), allocatable :: val TOML value to append to table integer, intent(out) :: stat Status of operation Source Code type , extends ( toml_value ) :: toml_table !> Table was implictly created logical :: implicit = . false . !> Is an inline table and is therefore non-extendable logical :: inline = . false . !> Storage unit for TOML values of this table class ( toml_structure ), allocatable :: list contains !> Get the TOML value associated with the respective key procedure :: get !> Get list of all keys in this table procedure :: get_keys !> Check if key is already present in this table instance procedure :: has_key !> Append value to table (checks automatically for key) procedure :: push_back !> Delete TOML value at a given key procedure :: delete !> Release allocation hold by TOML table procedure :: destroy end type toml_table","tags":"","loc":"type/toml_table.html"},{"title":"toml_array – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_array TOML array Contents Variables inline key list Constructor toml_array Type-Bound Procedures accept destroy get get_key match_key pop push_back shift Source Code toml_array Components Type Visibility Attributes Name Initial logical, public :: inline = .true. Is an inline array rather than an array of tables character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value class( toml_ordered ), public, allocatable :: list Storage unit for TOML values of this array Constructor public interface toml_array Create standard constructor private function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: destroy Release allocation hold by TOML array private subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array procedure, public :: get Get the TOML value at a given index private subroutine get(self, idx, ptr) Get the TOML value at the respective index Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array integer, intent(in) :: idx Index to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the TOML value procedure, public :: get_key Get escaped key to TOML value private subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=*), intent(in) :: key TOML raw key to compare to Return Value logical procedure, public :: pop Remove the last element from the array private subroutine pop(self, val) Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure, public :: push_back Append value to array private subroutine push_back(self, val, stat) Push back a TOML value to the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(inout), allocatable :: val TOML value to append to array integer, intent(out) :: stat Status of operation procedure, public :: shift Remove the first element from the array private subroutine shift(self, val) Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , extends ( toml_value ) :: toml_array !> Is an inline array rather than an array of tables logical :: inline = . true . !> Storage unit for TOML values of this array class ( toml_ordered ), allocatable :: list contains !> Get the TOML value at a given index procedure :: get !> Append value to array procedure :: push_back !> Remove the first element from the array procedure :: shift !> Remove the last element from the array procedure :: pop !> Release allocation hold by TOML array procedure :: destroy end type toml_array","tags":"","loc":"type/toml_array.html"},{"title":"toml_keyval – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_keyval TOML key-value pair Contents Variables key raw Type-Bound Procedures accept destroy get_key match_key Source Code toml_keyval Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value character(kind=tfc,len=:), public, allocatable :: raw Raw content of the TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: destroy Release allocation hold by TOML key-value pair private subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair procedure, public :: get_key Get escaped key to TOML value private subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc,len=*), intent(in) :: key TOML raw key to compare to Return Value logical Source Code type , extends ( toml_value ) :: toml_keyval !> Raw content of the TOML value character ( kind = tfc , len = :), allocatable :: raw contains !> Release allocation hold by TOML key-value pair procedure :: destroy end type toml_keyval","tags":"","loc":"type/toml_keyval.html"},{"title":"toml_token – TOML-Fortran ","text":"type, public :: toml_token Basic TOML token, produced by a TOML tokenizer Contents Variables len ptr tok Source Code toml_token Components Type Visibility Attributes Name Initial integer, public :: len = 0 Length of the token at ptr character(len=:), public, pointer :: ptr => null() Character representation of the token integer, public :: tok = toml_tokentype%invalid Actual tokentype Source Code type :: toml_token !> Actual tokentype integer :: tok = toml_tokentype % invalid !> Character representation of the token character ( len = :), pointer :: ptr => null () !> Length of the token at ptr integer :: len = 0 end type toml_token","tags":"","loc":"type/toml_token.html"},{"title":"toml_tokenizer – TOML-Fortran ","text":"type, public, abstract :: toml_tokenizer Abstract TOML tokenizer Contents Variables current error finished line root tok Type-Bound Procedures next_token parse Source Code toml_tokenizer Components Type Visibility Attributes Name Initial type( toml_table ), public, pointer :: current => null() Pointer to the current table while transversing a table path type( toml_error ), public, allocatable :: error Error buffer, if allocated an error has occurred logical, public :: finished = .false. Signals if the tokenizer has finished (EOF has been reached) type( toml_context ), public :: line Current line (for error handling) type( toml_table ), public, allocatable :: root Root table type( toml_token ), public :: tok Current token Type-Bound Procedures procedure(next_token), public, deferred :: next_token Return next token subroutine next_token(de, dot_is_token) Prototype Return next token Arguments Type Intent Optional Attributes Name class( toml_tokenizer ), intent(inout) :: de Instance of the tokenizer logical, intent(in) :: dot_is_token Dot should be handled as token procedure, public :: parse => parse_root Entry point for parsing the TOML document, creates the root table private subroutine parse_root(de) Entry point for parsing the TOML document, creates the root table Arguments Type Intent Optional Attributes Name class( toml_tokenizer ), intent(inout), target :: de Instance of the TOML deserializer Source Code type , abstract :: toml_tokenizer !> Signals if the tokenizer has finished (EOF has been reached) logical :: finished = . false . !> Current token type ( toml_token ) :: tok !> Root table type ( toml_table ), allocatable :: root !> Pointer to the current table while transversing a table path type ( toml_table ), pointer :: current => null () !> Current line (for error handling) type ( toml_context ) :: line !> Error buffer, if allocated an error has occurred type ( toml_error ), allocatable :: error contains !> Entry point for parsing the TOML document, creates the root table procedure :: parse => parse_root !> Parse a TOML table or array of tables header procedure , private :: parse_select !> Parse an inline TOML array procedure , private :: parse_array !> Parse an inline TOML table procedure , private :: parse_table !> Parse a key-value pair procedure , private :: parse_keyval !> Advance tokenizer procedure , private :: next !> Return next token procedure ( next_token ), deferred :: next_token end type toml_tokenizer","tags":"","loc":"type/toml_tokenizer.html"},{"title":"toml_character_tokenizer – TOML-Fortran ","text":"type, public, extends( toml_tokenizer ) :: toml_character_tokenizer Tokenizer for a sequence of characters Contents Variables conf current error finished line root tok Type-Bound Procedures next_token parse Source Code toml_character_tokenizer Components Type Visibility Attributes Name Initial character(len=:), public, pointer :: conf Link to the input configuration. type( toml_table ), public, pointer :: current => null() Pointer to the current table while transversing a table path type( toml_error ), public, allocatable :: error Error buffer, if allocated an error has occurred logical, public :: finished = .false. Signals if the tokenizer has finished (EOF has been reached) type( toml_context ), public :: line Current line (for error handling) type( toml_table ), public, allocatable :: root Root table type( toml_token ), public :: tok Current token Type-Bound Procedures procedure, public :: next_token Return next token private subroutine next_token(de, dot_is_token) Return next token Read more… Arguments Type Intent Optional Attributes Name class( toml_character_tokenizer ), intent(inout) :: de Instance of the tokenizer logical, intent(in) :: dot_is_token Dot should be handled as token procedure, public :: parse => parse_root Entry point for parsing the TOML document, creates the root table private subroutine parse_root(de) Entry point for parsing the TOML document, creates the root table Arguments Type Intent Optional Attributes Name class( toml_tokenizer ), intent(inout), target :: de Instance of the TOML deserializer Source Code type , extends ( toml_tokenizer ) :: toml_character_tokenizer !> Link to the input configuration. character ( len = :), pointer :: conf contains !> Return next token procedure :: next_token end type toml_character_tokenizer","tags":"","loc":"type/toml_character_tokenizer.html"},{"title":"is_array_of_tables – TOML-Fortran","text":"public function is_array_of_tables(array) result(only_tables) Determine if array contains only tables Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array TOML value to visit Return Value logical Array contains only tables Contents Source Code is_array_of_tables Source Code function is_array_of_tables ( array ) result ( only_tables ) !> TOML value to visit class ( toml_array ), intent ( inout ) :: array !> Array contains only tables logical :: only_tables class ( toml_value ), pointer :: ptr integer :: i , n n = len ( array ) only_tables = n > 0 do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) type is ( toml_table ) cycle class default only_tables = . false . exit end select end do end function is_array_of_tables","tags":"","loc":"proc/is_array_of_tables.html"},{"title":"add_array – TOML-Fortran","text":"public interface add_array Interface to build new arrays Contents Module Procedures add_array_to_table add_array_to_array Module Procedures private subroutine add_array_to_table(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private subroutine add_array_to_array(array, ptr, stat) Create a new TOML array inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/add_array.html"},{"title":"add_keyval – TOML-Fortran","text":"public interface add_keyval Interface to build new key-value pairs Contents Module Procedures add_keyval_to_table add_keyval_to_array Module Procedures private subroutine add_keyval_to_table(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private subroutine add_keyval_to_array(array, ptr, stat) Create a new key-value pair inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/add_keyval.html"},{"title":"add_table – TOML-Fortran","text":"public interface add_table Interface to build new tables Contents Module Procedures add_table_to_table add_table_to_array Module Procedures private subroutine add_table_to_table(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private subroutine add_table_to_array(array, ptr, stat) Create a new TOML table inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/add_table.html"},{"title":"toml_get_value_type – TOML-Fortran","text":"public function toml_get_value_type(raw) result(vtype) Determine TOML value type Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw representation of TOML string Return Value integer Value type Contents None","tags":"","loc":"proc/toml_get_value_type.html"},{"title":"toml_escape_string – TOML-Fortran","text":"public subroutine toml_escape_string(raw, escaped) Escape all special characters in a TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw representation of TOML string character(kind=tfc,len=:), intent(out), allocatable :: escaped Escaped view of the TOML string Contents Source Code toml_escape_string Source Code subroutine toml_escape_string ( raw , escaped ) !> Raw representation of TOML string character ( kind = tfc , len =* ), intent ( in ) :: raw !> Escaped view of the TOML string character ( kind = tfc , len = :), allocatable , intent ( out ) :: escaped integer :: i escaped = '\"' do i = 1 , len ( raw ) select case ( raw ( i : i )) case default ; escaped = escaped // raw ( i : i ) case ( '\\'); escaped = escaped // ' \\\\ ' case(' \"'); escaped = escaped // '\\\"' case(TOML_NEWLINE); escaped = escaped // '\\n' case(TOML_FORMFEED); escaped = escaped // '\\f' case(TOML_CARRIAGE_RETURN); escaped = escaped // '\\r' case(TOML_TABULATOR); escaped = escaped // '\\t' case(TOML_BACKSPACE); escaped = escaped // '\\b' end select end do escaped = escaped // '\" ' end subroutine toml_escape_string","tags":"","loc":"proc/toml_escape_string.html"},{"title":"toml_parse – TOML-Fortran","text":"public interface toml_parse Contents Module Procedures toml_parse_unit toml_parse_string Module Procedures private subroutine toml_parse_unit(table, unit, error) Parse a TOML input from a given IO unit. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table integer, intent(in) :: unit type( toml_error ), intent(out), optional allocatable :: error private subroutine toml_parse_string(table, conf, error) Wrapper to parse a TOML string.\n connect deserializer to configuration Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table character(len=*), intent(in), target :: conf type( toml_error ), intent(out), optional allocatable :: error","tags":"","loc":"interface/toml_parse.html"},{"title":"duplicate_key_error – TOML-Fortran","text":"public subroutine duplicate_key_error(error, context, key, stat) Key is present multiple times in a TOML document within the same table Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: key The offending duplicate key integer, intent(in), optional :: stat Overwrite of the error code Contents Source Code duplicate_key_error Source Code subroutine duplicate_key_error ( error , context , key , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> The offending duplicate key character ( kind = tfc , len =* ), intent ( in ), optional :: key !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % duplicate_key end if if ( present ( key )) then error % message = \"Duplicate key (\" // key // \") found\" else error % message = \"Duplicate key found\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine duplicate_key_error","tags":"","loc":"proc/duplicate_key_error.html"},{"title":"io_error – TOML-Fortran","text":"public subroutine io_error(error, message) IO runtime error Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice Contents Source Code io_error Source Code subroutine io_error ( error , message ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message allocate ( error ) error % stat = toml_stat % io_failure if ( present ( message )) then error % message = message else error % message = \"IO runtime error\" end if end subroutine io_error","tags":"","loc":"proc/io_error.html"},{"title":"syntax_error – TOML-Fortran","text":"public subroutine syntax_error(error, context, message, stat) A syntactic error in a TOML document was found Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code Contents Source Code syntax_error Source Code subroutine syntax_error ( error , context , message , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % invalid_syntax end if if ( present ( message )) then error % message = message else error % message = \"Syntax error\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine syntax_error","tags":"","loc":"proc/syntax_error.html"},{"title":"vendor_error – TOML-Fortran","text":"public subroutine vendor_error(error, context, message, stat) A shortcoming in the implementation or an internal error occured, rather Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code Contents Source Code vendor_error Source Code subroutine vendor_error ( error , context , message , stat ) !> Instance of the TOML error type ( toml_error ), allocatable , intent ( out ) :: error !> Current context producing the error type ( toml_context ), intent ( in ), optional :: context !> A detailed message describing the error and (optionally) offering advice character ( kind = tfc , len =* ), intent ( in ), optional :: message !> Overwrite of the error code integer , intent ( in ), optional :: stat allocate ( error ) if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % fatal end if if ( present ( message )) then error % message = message else error % message = \"Internal error\" end if if ( present ( context )) then call add_context ( error % message , context ) end if end subroutine vendor_error","tags":"","loc":"proc/vendor_error.html"},{"title":"new_serializer – TOML-Fortran","text":"public subroutine new_serializer(self, unit) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer integer, intent(in), optional :: unit Unit for IO Contents Source Code new_serializer Source Code subroutine new_serializer ( self , unit ) !> Instance of the TOML serializer type ( toml_serializer ), intent ( out ) :: self !> Unit for IO integer , intent ( in ), optional :: unit if ( present ( unit )) then self % unit = unit end if end subroutine new_serializer","tags":"","loc":"proc/new_serializer.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML serializers Contents Module Procedures new_serializer Module Procedures public subroutine new_serializer (self, unit) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer integer, intent(in), optional :: unit Unit for IO","tags":"","loc":"interface/new.html"},{"title":"toml_serializer – TOML-Fortran","text":"public interface toml_serializer Create standard constructor Contents Module Procedures new_serializer_func Module Procedures private function new_serializer_func(unit) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: unit Unit for IO Return Value type( toml_serializer ) Instance of the TOML serializer","tags":"","loc":"interface/toml_serializer.html"},{"title":"new_ordered – TOML-Fortran","text":"public subroutine new_ordered(self) Constructor for the ordered storage data structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(out), allocatable :: self Instance of the structure Contents Source Code new_ordered Source Code subroutine new_ordered ( self ) !> Instance of the structure class ( toml_ordered ), allocatable , intent ( out ) :: self type ( toml_vector ), allocatable :: vect allocate ( vect ) call new_vector ( vect ) call move_alloc ( vect , self ) end subroutine new_ordered","tags":"","loc":"proc/new_ordered.html"},{"title":"new_structure – TOML-Fortran","text":"public subroutine new_structure(self) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(out), allocatable :: self Instance of the structure Contents Source Code new_structure Source Code subroutine new_structure ( self ) !> Instance of the structure class ( toml_structure ), allocatable , intent ( out ) :: self type ( toml_vector ), allocatable :: vect allocate ( vect ) call new_vector ( vect ) call move_alloc ( vect , self ) end subroutine new_structure","tags":"","loc":"proc/new_structure.html"},{"title":"len – TOML-Fortran","text":"public interface len Overload len function Contents Module Procedures get_len Module Procedures private pure function get_len(self) result(length) Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(in) :: self Instance of the structure Return Value integer Current length of the ordered structure","tags":"","loc":"interface/len.html"},{"title":"get_tomlf_version – TOML-Fortran","text":"public subroutine get_tomlf_version(major, minor, patch, string) Getter function to retrieve TOML-Fortran version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the TOML-Fortran version integer, intent(out), optional :: minor Minor version number of the TOML-Fortran version integer, intent(out), optional :: patch Patch version number of the TOML-Fortran version character(len=:), intent(out), optional allocatable :: string String representation of the TOML-Fortran version Contents Source Code get_tomlf_version Source Code subroutine get_tomlf_version ( major , minor , patch , string ) !> Major version number of the TOML-Fortran version integer , intent ( out ), optional :: major !> Minor version number of the TOML-Fortran version integer , intent ( out ), optional :: minor !> Patch version number of the TOML-Fortran version integer , intent ( out ), optional :: patch !> String representation of the TOML-Fortran version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = tomlf_major end if if ( present ( minor )) then minor = tomlf_minor end if if ( present ( patch )) then patch = tomlf_patch end if if ( present ( string )) then string = tomlf_version_string end if end subroutine get_tomlf_version","tags":"","loc":"proc/get_tomlf_version.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML tables Contents Module Procedures get_child_table get_child_array get_child_keyval get_child_value_float_sp get_child_value_float_dp get_child_value_integer_i1 get_child_value_integer_i2 get_child_value_integer_i4 get_child_value_integer_i8 get_child_value_bool get_child_value_string Module Procedures private subroutine get_child_table(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_array(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_keyval(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_float_sp(table, key, val, default, stat) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_float_dp(table, key, val, default, stat) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i1(table, key, val, default, stat) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i2(table, key, val, default, stat) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i4(table, key, val, default, stat) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i8(table, key, val, default, stat) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_bool(table, key, val, default, stat) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_string(table, key, val, default, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table character(kind=tfc,len=:), intent(out), allocatable :: val String value character(kind=tfc,len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/get_value.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML tables Contents Module Procedures set_child_value_float_sp set_child_value_float_dp set_child_value_integer_i1 set_child_value_integer_i2 set_child_value_integer_i4 set_child_value_integer_i8 set_child_value_bool set_child_value_string Module Procedures private subroutine set_child_value_float_sp(table, key, val, stat) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_float_dp(table, key, val, stat) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i1(table, key, val, stat) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i2(table, key, val, stat) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i4(table, key, val, stat) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i8(table, key, val, stat) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_bool(table, key, val, stat) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_string(table, key, val, stat) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/set_value.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML arrays Contents Module Procedures get_elem_table get_elem_array get_elem_keyval get_elem_value_string get_elem_value_float_sp get_elem_value_float_dp get_elem_value_int_i1 get_elem_value_int_i2 get_elem_value_int_i4 get_elem_value_int_i8 get_elem_value_bool Module Procedures private subroutine get_elem_table(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_table ), intent(out), pointer :: ptr Pointer to child table integer, intent(out), optional :: stat Status of operation private subroutine get_elem_array(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_array ), intent(out), pointer :: ptr Pointer to child array integer, intent(out), optional :: stat Status of operation private subroutine get_elem_keyval(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_string(array, pos, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc,len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_float_sp(array, pos, val, stat) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_float_dp(array, pos, val, stat) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i1(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i2(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i4(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i8(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_bool(array, pos, val, stat) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/get_value~2.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML arrays Contents Module Procedures set_elem_value_string set_elem_value_float_sp set_elem_value_float_dp set_elem_value_int_i1 set_elem_value_int_i2 set_elem_value_int_i4 set_elem_value_int_i8 set_elem_value_bool Module Procedures private subroutine set_elem_value_string(array, pos, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_float_sp(array, pos, val, stat) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_float_dp(array, pos, val, stat) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i1(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i2(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i4(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i8(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_bool(array, pos, val, stat) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/set_value~2.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML values Contents Module Procedures get_value_float_sp get_value_float_dp get_value_integer_i1 get_value_integer_i2 get_value_integer_i4 get_value_integer_i8 get_value_bool get_value_string Module Procedures private subroutine get_value_float_sp(self, val, stat) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_sp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine get_value_float_dp(self, val, stat) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_dp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i1(self, val, stat) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i2(self, val, stat) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i4(self, val, stat) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i8(self, val, stat) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_bool(self, val, stat) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair logical, intent(out) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine get_value_string(self, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair character(kind=tfc,len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/get_value~3.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML values Contents Module Procedures set_value_float_sp set_value_float_dp set_value_integer_i1 set_value_integer_i2 set_value_integer_i4 set_value_integer_i8 set_value_bool set_value_string Module Procedures private subroutine set_value_float_sp(self, val, stat) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_value_float_dp(self, val, stat) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i1(self, val, stat) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i2(self, val, stat) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i4(self, val, stat) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i8(self, val, stat) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_bool(self, val, stat) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine set_value_string(self, val, stat) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"interface/set_value~3.html"},{"title":"merge_array – TOML-Fortran","text":"public recursive subroutine merge_array(lhs, rhs) Append values from one TOML array to another Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: lhs Instance of array to merge into class( toml_array ), intent(inout) :: rhs Instance of array to be merged Contents Source Code merge_array Source Code recursive subroutine merge_array ( lhs , rhs ) !> Instance of array to merge into class ( toml_array ), intent ( inout ) :: lhs !> Instance of array to be merged class ( toml_array ), intent ( inout ) :: rhs class ( toml_value ), pointer :: ptr class ( toml_value ), allocatable :: tmp integer :: n , i , stat n = len ( rhs ) do i = 1 , n call rhs % get ( i , ptr ) if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp , source = ptr ) call lhs % push_back ( tmp , stat ) end do end subroutine merge_array","tags":"","loc":"proc/merge_array.html"},{"title":"merge_table – TOML-Fortran","text":"public recursive subroutine merge_table(lhs, rhs) Merge TOML tables by appending their values Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: lhs Instance of table to merge into class( toml_table ), intent(inout) :: rhs Instance of table to be merged Contents Source Code merge_table Source Code recursive subroutine merge_table ( lhs , rhs ) !> Instance of table to merge into class ( toml_table ), intent ( inout ) :: lhs !> Instance of table to be merged class ( toml_table ), intent ( inout ) :: rhs type ( toml_key ), allocatable :: list (:) class ( toml_value ), pointer :: ptr1 , ptr2 class ( toml_value ), allocatable :: tmp logical :: has_key integer :: i , n , stat call rhs % get_keys ( list ) n = size ( list , 1 ) do i = 1 , n if ( allocated ( tmp )) deallocate ( tmp ) call rhs % get ( list ( i )% key , ptr1 ) has_key = lhs % has_key ( list ( i )% key ) select type ( ptr1 ) class is ( toml_keyval ) if (. not . has_key ) then allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if class is ( toml_array ) if ( has_key ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_array ) call merge_array ( ptr2 , ptr1 ) end select else allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if class is ( toml_table ) if ( has_key ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_table ) call merge_table ( ptr2 , ptr1 ) end select else allocate ( tmp , source = ptr1 ) call lhs % push_back ( tmp , stat ) end if end select end do end subroutine merge_table","tags":"","loc":"proc/merge_table.html"},{"title":"new_vector – TOML-Fortran","text":"public subroutine new_vector(self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_vector ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity Contents Source Code new_vector Source Code subroutine new_vector ( self , n ) !> Instance of the structure type ( toml_vector ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_vector","tags":"","loc":"proc/new_vector.html"},{"title":"toml_raw_verify_bool – TOML-Fortran","text":"public pure function toml_raw_verify_bool(raw) result(stat) Verify a raw value as TOML bool Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_bool Source Code pure function toml_raw_verify_bool ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat stat = raw == 'true' . or . raw == 'false' end function toml_raw_verify_bool","tags":"","loc":"proc/toml_raw_verify_bool.html"},{"title":"toml_raw_verify_date – TOML-Fortran","text":"public pure function toml_raw_verify_date(raw) result(stat) Verify a raw value as TOML date expression (YYYY-MM-DD) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_date Source Code pure function toml_raw_verify_date ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat if ( len ( raw ) >= 10 ) then stat = verify ( raw ( 1 : 4 ), TOML_DIGITS ) == 0 . and . raw ( 5 : 5 ) == '-' . and . & & verify ( raw ( 6 : 7 ), TOML_DIGITS ) == 0 . and . raw ( 8 : 8 ) == '-' . and . & & verify ( raw ( 9 : 10 ), TOML_DIGITS ) == 0 else stat = . false . end if end function toml_raw_verify_date","tags":"","loc":"proc/toml_raw_verify_date.html"},{"title":"toml_raw_verify_float – TOML-Fortran","text":"public pure function toml_raw_verify_float(raw) result(stat) Verify a raw value as TOML float Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_float Source Code pure function toml_raw_verify_float ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat logical :: plus_minus integer :: first integer :: dot_pos integer :: exp_pos first = 1 stat = . false . if ( raw == 'nan' ) then stat = . true . return end if ! allow leading + or - plus_minus = raw ( 1 : 1 ) == '+' . or . raw ( 1 : 1 ) == '-' if ( plus_minus ) first = first + 1 ! allow infinity and not-a-number if ( raw ( first :) == 'inf' . or . raw ( first :) == 'nan' ) then stat = . true . return end if ! position of dot and exponent dot_pos = index ( raw , '.' ) exp_pos = scan ( raw , 'Ee' ) if ( dot_pos == 0 . and . exp_pos == 0 ) return if ( dot_pos > 0 . and . exp_pos > 0 . and . dot_pos > exp_pos ) return ! check for leading or trailing underscores if ( raw ( first : first ) == '_' . or . raw ( len ( raw ):) == '_' ) return ! check for leading or trailing dots if ( first == dot_pos . or . len ( raw ) == dot_pos ) return if ( dot_pos > 0 ) then if ( raw ( dot_pos + 1 : dot_pos + 1 ) == '_' . or . raw ( dot_pos - 1 : dot_pos - 1 ) == '_' ) return end if ! zero must be followed by a dot or exponent if ( raw ( first : first ) == '0' . and . len ( raw ( first :)) > 1 ) then if ( first + 1 /= dot_pos . and . first + 1 /= exp_pos ) return end if ! no double underscores if ( index ( raw , '__' ) > 0 ) return ! check for digits stat = verify ( raw ( first :), TOML_DIGITS // '._-+eE' ) == 0 end function toml_raw_verify_float","tags":"","loc":"proc/toml_raw_verify_float.html"},{"title":"toml_raw_verify_integer – TOML-Fortran","text":"public pure function toml_raw_verify_integer(raw) result(stat) Verify a raw value as TOML integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents None","tags":"","loc":"proc/toml_raw_verify_integer.html"},{"title":"toml_raw_verify_string – TOML-Fortran","text":"public pure function toml_raw_verify_string(raw) result(stat) Verify a raw value as TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_string Source Code pure function toml_raw_verify_string ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat stat = raw ( 1 : 1 ) == TOML_SQUOTE . or . raw ( 1 : 1 ) == TOML_DQUOTE end function toml_raw_verify_string","tags":"","loc":"proc/toml_raw_verify_string.html"},{"title":"toml_raw_verify_time – TOML-Fortran","text":"public pure function toml_raw_verify_time(raw) result(stat) Verify a raw value as TOML time expression (HH:MM:SS) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_time Source Code pure function toml_raw_verify_time ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat if ( len ( raw ) >= 8 ) then stat = verify ( raw ( 1 : 2 ), TOML_DIGITS ) == 0 . and . raw ( 3 : 3 ) == ':' . and . & & verify ( raw ( 4 : 5 ), TOML_DIGITS ) == 0 . and . raw ( 6 : 6 ) == ':' . and . & & verify ( raw ( 7 : 8 ), TOML_DIGITS ) == 0 else stat = . false . end if end function toml_raw_verify_time","tags":"","loc":"proc/toml_raw_verify_time.html"},{"title":"toml_raw_verify_timestamp – TOML-Fortran","text":"public pure function toml_raw_verify_timestamp(raw) result(stat) Verify a raw value as TOML datetime expression Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation Contents Source Code toml_raw_verify_timestamp Source Code pure function toml_raw_verify_timestamp ( raw ) result ( stat ) !> Raw value to verify character ( kind = tfc , len =* ), intent ( in ) :: raw !> Status of the evaluation logical :: stat integer :: first first = 1 stat = . false . if ( toml_raw_verify_date ( raw )) then if ( len ( raw ) == 10 ) then stat = . true . return end if if ( raw ( 11 : 11 ) /= ' ' . and . raw ( 11 : 11 ) /= 'T' ) return first = 12 end if stat = toml_raw_verify_time ( raw ( first :)) end function toml_raw_verify_timestamp","tags":"","loc":"proc/toml_raw_verify_timestamp.html"},{"title":"toml_raw_to_bool – TOML-Fortran","text":"public function toml_raw_to_bool(raw, bool) result(stat) Attempt to convert TOML raw value to Fortran logical Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert logical, intent(out) :: bool Logical value represented by raw value Return Value logical Status of the evaluation Contents Source Code toml_raw_to_bool Source Code function toml_raw_to_bool ( raw , bool ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> Logical value represented by raw value logical , intent ( out ) :: bool !> Status of the evaluation logical :: stat stat = toml_raw_verify_bool ( raw ) if ( stat ) then select case ( raw ) case ( 'true' ); bool = . true . case ( 'false' ); bool = . false . end select end if end function toml_raw_to_bool","tags":"","loc":"proc/toml_raw_to_bool.html"},{"title":"toml_raw_to_float – TOML-Fortran","text":"public function toml_raw_to_float(raw, num) result(stat) Attempt to convert TOML raw value to Fortran real Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert real(kind=tfr), intent(out) :: num Real value represented by raw value Return Value logical Status of the evaluation Contents None","tags":"","loc":"proc/toml_raw_to_float.html"},{"title":"toml_raw_to_integer – TOML-Fortran","text":"public function toml_raw_to_integer(raw, num) result(stat) Attempt to convert TOML raw value to Fortran integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert integer(kind=tfi), intent(out) :: num Integer value represented by raw value Return Value logical Status of the evaluation Contents Source Code toml_raw_to_integer Source Code function toml_raw_to_integer ( raw , num ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> Integer value represented by raw value integer ( tfi ), intent ( out ) :: num !> Status of the evaluation logical :: stat character ( kind = tfc , len = len ( raw )) :: inp character ( len = 10 ) :: fmt logical :: minus integer :: i , j , err integer :: first stat = toml_raw_verify_integer ( raw ) if ( stat ) then minus = raw ( 1 : 1 ) == '-' inp = '' first = scan ( raw , 'xob' ) + 1 j = 0 do i = first , len ( raw ) if ( raw ( i : i ) == '_' ) cycle j = j + 1 inp ( j : j ) = raw ( i : i ) end do if ( first > 1 ) then select case ( raw ( first - 1 : first - 1 )) case ( 'x' ); write ( fmt , '(\"(z\",i0,\")\")' ) j case ( 'o' ); write ( fmt , '(\"(o\",i0,\")\")' ) j case ( 'b' ); write ( fmt , '(\"(b\",i0,\")\")' ) j end select read ( inp , fmt , iostat = err ) num if ( minus ) num = - num else read ( inp , * , iostat = err ) num end if stat = err == 0 end if end function toml_raw_to_integer","tags":"","loc":"proc/toml_raw_to_integer.html"},{"title":"toml_raw_to_string – TOML-Fortran","text":"public function toml_raw_to_string(raw, str) result(stat) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw character(kind=tfc,len=:), intent(out), allocatable :: str Return Value logical Contents Source Code toml_raw_to_string Source Code logical function toml_raw_to_string ( raw , str ) result ( stat ) character ( kind = tfc , len =* ), intent ( in ) :: raw character ( kind = tfc , len = :), allocatable , intent ( out ) :: str character ( kind = tfc , len = :), allocatable :: tmp logical :: multiline logical :: verbatim stat = toml_raw_verify_string ( raw ) if ( stat ) then verbatim = raw ( 1 : 1 ) == TOML_SQUOTE multiline = verify ( raw ( 1 : 3 ), TOML_DQUOTE ) == 0 & & . or . verify ( raw ( 1 : 3 ), TOML_SQUOTE ) == 0 if ( multiline ) then tmp = raw ( 4 : len ( raw ) - 3 ) call toml_normalize_multiline ( tmp ) else tmp = raw ( 2 : len ( raw ) - 1 ) end if if (. not . verbatim ) call toml_normalize_string ( tmp ) call move_alloc ( tmp , str ) end if end function toml_raw_to_string","tags":"","loc":"proc/toml_raw_to_string.html"},{"title":"toml_raw_to_timestamp – TOML-Fortran","text":"public function toml_raw_to_timestamp(raw, timestamp) result(stat) Attempt to convert TOML raw value to TOML datetime Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert type( toml_datetime ), intent(out) :: timestamp TOML datetime value Return Value logical Status of the evaluation Contents Source Code toml_raw_to_timestamp Source Code function toml_raw_to_timestamp ( raw , timestamp ) result ( stat ) !> Raw value to convert character ( kind = tfc , len =* ), intent ( in ) :: raw !> TOML datetime value type ( toml_datetime ), intent ( out ) :: timestamp !> Status of the evaluation logical :: stat integer :: err , dot_pos , first stat = toml_raw_verify_timestamp ( raw ) first = 1 if ( toml_raw_verify_date ( raw )) then timestamp % date = toml_date () read ( raw ( 1 : 4 ), * , iostat = err ) timestamp % date % year stat = err == 0 read ( raw ( 6 : 7 ), * , iostat = err ) timestamp % date % month stat = stat . and . err == 0 read ( raw ( 9 : 10 ), * , iostat = err ) timestamp % date % day stat = stat . and . err == 0 if (. not . stat . or . len ( raw ) == 10 ) return first = 12 end if if ( toml_raw_verify_time ( raw ( first :))) then timestamp % time = toml_time () read ( raw ( first : first + 1 ), * , iostat = err ) timestamp % time % hour stat = err == 0 read ( raw ( first + 3 : first + 4 ), * , iostat = err ) timestamp % time % minute stat = stat . and . err == 0 read ( raw ( first + 6 : first + 7 ), * , iostat = err ) timestamp % time % second stat = stat . and . err == 0 if ( len ( raw ( first :)) > 8 ) then dot_pos = index ( raw , '.' ) if ( dot_pos > 0 ) then allocate ( timestamp % time % millisec , source = 0 ) read ( raw ( dot_pos + 1 : dot_pos + 3 ), * , iostat = err ) timestamp % time % millisec stat = stat . and . err == 0 end if dot_pos = verify ( raw ( first :), TOML_DIGITS // '.:' ) + first - 1 if ( dot_pos > first ) timestamp % time % zone = raw ( dot_pos :) end if end if end function toml_raw_to_timestamp","tags":"","loc":"proc/toml_raw_to_timestamp.html"},{"title":"convert_raw – TOML-Fortran","text":"public interface convert_raw Overloaded conversion interface Contents Module Procedures toml_raw_to_string toml_raw_to_float toml_raw_to_bool toml_raw_to_integer toml_raw_to_timestamp Module Procedures public function toml_raw_to_string (raw, str) result(stat) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw character(kind=tfc,len=:), intent(out), allocatable :: str Return Value logical public function toml_raw_to_float (raw, num) result(stat) Attempt to convert TOML raw value to Fortran real Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert real(kind=tfr), intent(out) :: num Real value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_bool (raw, bool) result(stat) Attempt to convert TOML raw value to Fortran logical Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert logical, intent(out) :: bool Logical value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_integer (raw, num) result(stat) Attempt to convert TOML raw value to Fortran integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert integer(kind=tfi), intent(out) :: num Integer value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_timestamp (raw, timestamp) result(stat) Attempt to convert TOML raw value to TOML datetime Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert type( toml_datetime ), intent(out) :: timestamp TOML datetime value Return Value logical Status of the evaluation","tags":"","loc":"interface/convert_raw.html"},{"title":"new_table – TOML-Fortran","text":"public subroutine new_table(self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table Contents Source Code new_table Source Code subroutine new_table ( self ) !> Instance of the TOML table type ( toml_table ), intent ( out ) :: self call new_structure ( self % list ) end subroutine new_table","tags":"","loc":"proc/new_table.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Contents Module Procedures new_table Module Procedures public subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table","tags":"","loc":"interface/new~2.html"},{"title":"toml_table – TOML-Fortran","text":"public interface toml_table Create standard constructor Contents Module Procedures new_table_func Module Procedures private function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table","tags":"","loc":"interface/toml_table.html"},{"title":"new_array – TOML-Fortran","text":"public subroutine new_array(self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array Contents Source Code new_array Source Code subroutine new_array ( self ) !> Instance of the TOML array type ( toml_array ), intent ( out ) :: self call new_ordered ( self % list ) end subroutine new_array","tags":"","loc":"proc/new_array.html"},{"title":"len – TOML-Fortran","text":"public interface len Overload len function Contents Module Procedures get_len Module Procedures private pure function get_len(self) result(length) Get number of TOML values in the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(in) :: self Instance of the TOML array Return Value integer Current length of the array","tags":"","loc":"interface/len~2.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Contents Module Procedures new_array Module Procedures public subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array","tags":"","loc":"interface/new~3.html"},{"title":"toml_array – TOML-Fortran","text":"public interface toml_array Create standard constructor Contents Module Procedures new_array_func Module Procedures private function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array","tags":"","loc":"interface/toml_array.html"},{"title":"new_keyval – TOML-Fortran","text":"public subroutine new_keyval(self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair Contents Source Code new_keyval Source Code subroutine new_keyval ( self ) !> Instance of the TOML key-value pair type ( toml_keyval ), intent ( out ) :: self associate ( self => self ); end associate end subroutine new_keyval","tags":"","loc":"proc/new_keyval.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Contents Module Procedures new_keyval Module Procedures public subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair","tags":"","loc":"interface/new~4.html"},{"title":"new_character_tokenizer – TOML-Fortran","text":"public subroutine new_character_tokenizer(de, conf) Constructor for the deserializer implementation.\n connect deserializer to configuration\n first token is an artifical newline Arguments Type Intent Optional Attributes Name type( toml_character_tokenizer ), intent(out) :: de character(len=*), intent(in), target :: conf Contents Source Code new_character_tokenizer Source Code subroutine new_character_tokenizer ( de , conf ) type ( toml_character_tokenizer ), intent ( out ) :: de character ( len =* ), intent ( in ), target :: conf !> connect deserializer to configuration de % conf => conf de % line % ptr => conf de % line % num = 1 !> first token is an artifical newline de % tok = new_token ( toml_tokentype % newline , de % conf , 0 ) end subroutine new_character_tokenizer","tags":"","loc":"proc/new_character_tokenizer.html"},{"title":"new – TOML-Fortran","text":"public interface new Contents Module Procedures new_character_tokenizer Module Procedures public subroutine new_character_tokenizer (de, conf) Constructor for the deserializer implementation.\n connect deserializer to configuration\n first token is an artifical newline Arguments Type Intent Optional Attributes Name type( toml_character_tokenizer ), intent(out) :: de character(len=*), intent(in), target :: conf","tags":"","loc":"interface/new~5.html"},{"title":"tomlf – TOML-Fortran","text":"Minimal public API for TOML-Fortran Uses tomlf_build tomlf_de tomlf_error tomlf_ser tomlf_type tomlf_version Contents None","tags":"","loc":"module/tomlf.html"},{"title":"tomlf_datetime – TOML-Fortran","text":"Implementation of a TOML datetime value Uses tomlf_constants Contents Derived Types toml_date toml_datetime toml_time Derived Types type, public :: toml_date TOML date value (YYYY-MM-DD) Components Type Visibility Attributes Name Initial integer, public :: day = 0 integer, public :: month = 0 integer, public :: year = 0 Type-Bound Procedures generic, public :: assignment(=) => to_string procedure, public, pass(rhs) :: to_string => date_to_string type, public :: toml_datetime TOML datatime value type Components Type Visibility Attributes Name Initial type( toml_date ), public, allocatable :: date type( toml_time ), public, allocatable :: time Type-Bound Procedures generic, public :: assignment(=) => to_string procedure, public, pass(rhs) :: to_string => datetime_to_string type, public :: toml_time TOML time value (HH:MM:SS.sssssZ…) Components Type Visibility Attributes Name Initial integer, public :: hour = 0 integer, public, allocatable :: millisec integer, public :: minute = 0 integer, public :: second = 0 character(len=:), public, allocatable :: zone Type-Bound Procedures generic, public :: assignment(=) => to_string procedure, public, pass(rhs) :: to_string => time_to_string","tags":"","loc":"module/tomlf_datetime.html"},{"title":"tomlf_all – TOML-Fortran","text":"Complete reexport of the public API of TOML-Fortran Uses tomlf_build tomlf_constants tomlf_datetime tomlf_de tomlf_error tomlf_ser tomlf_structure tomlf_type tomlf_utils tomlf_version Contents None","tags":"","loc":"module/tomlf_all.html"},{"title":"tomlf_constants – TOML-Fortran","text":"Uses iso_fortran_env Contents Variables TOML_BACKSPACE TOML_BAREKEY TOML_BINDIGITS TOML_CARRIAGE_RETURN TOML_DIGITS TOML_DQUOTE TOML_FORMFEED TOML_HEXDIGITS TOML_LETTERS TOML_LITERALS TOML_LOWERCASE TOML_NEWLINE TOML_OCTDIGITS TOML_SQUOTE TOML_TABULATOR TOML_TIMESTAMP TOML_UPPERCASE TOML_WHITESPACE tf_dp tf_i1 tf_i2 tf_i4 tf_i8 tf_sp tfc tfi tfout tfr toml_escape toml_type Variables Type Visibility Attributes Name Initial character(kind=tfc,len=*), public, parameter :: TOML_BACKSPACE = achar(8) character(kind=tfc,len=*), public, parameter :: TOML_BAREKEY = TOML_LETTERS//TOML_DIGITS//'_-' Allowed characters in TOML bare keys. character(kind=tfc,len=*), public, parameter :: TOML_BINDIGITS = '01' character(kind=tfc,len=*), public, parameter :: TOML_CARRIAGE_RETURN = achar(13) character(kind=tfc,len=*), public, parameter :: TOML_DIGITS = '0123456789' character(kind=tfc,len=*), public, parameter :: TOML_DQUOTE = '\"' Double quotes denote strings (with escape character possible) character(kind=tfc,len=*), public, parameter :: TOML_FORMFEED = achar(12) character(kind=tfc,len=*), public, parameter :: TOML_HEXDIGITS = '0123456789ABCDEFabcdef' character(kind=tfc,len=*), public, parameter :: TOML_LETTERS = TOML_LOWERCASE//TOML_UPPERCASE character(kind=tfc,len=*), public, parameter :: TOML_LITERALS = TOML_LETTERS//TOML_DIGITS//'_-+.' character(kind=tfc,len=*), public, parameter :: TOML_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz' character(kind=tfc,len=*), public, parameter :: TOML_NEWLINE = new_line('a') character(kind=tfc,len=*), public, parameter :: TOML_OCTDIGITS = '01234567' character(kind=tfc,len=*), public, parameter :: TOML_SQUOTE = \"'\" Single quotes denote literal strings character(kind=tfc,len=*), public, parameter :: TOML_TABULATOR = achar(9) character(kind=tfc,len=*), public, parameter :: TOML_TIMESTAMP = TOML_DIGITS//'.:+-T Zz' character(kind=tfc,len=*), public, parameter :: TOML_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character(kind=tfc,len=*), public, parameter :: TOML_WHITESPACE = ' '//toml_escape%tabulator Whitespace in TOML are blanks and tabs. integer, public, parameter :: tf_dp = selected_real_kind(15) Double precision real numbers integer, public, parameter :: tf_i1 = selected_int_kind(2) Char length for integers integer, public, parameter :: tf_i2 = selected_int_kind(4) Short length for integers integer, public, parameter :: tf_i4 = selected_int_kind(9) Length of default integers integer, public, parameter :: tf_i8 = selected_int_kind(18) Long length for integers integer, public, parameter :: tf_sp = selected_real_kind(6) Single precision real numbers integer, public, parameter :: tfc = selected_char_kind('DEFAULT') Default character kind integer, public, parameter :: tfi = tf_i8 Default integer precision, 64 bit (signed long) range expected integer, public, parameter :: tfout = output_unit Default output channel integer, public, parameter :: tfr = tf_dp Default float precision, IEEE 754 binary64 values expected type(enum_escape), public, parameter :: toml_escape = enum_escape() Actual enumerator with TOML escape characters type(enum_type), public, parameter :: toml_type = enum_type() Actual enumerator with TOML value types","tags":"","loc":"module/tomlf_constants.html"},{"title":"tomlf_build – TOML-Fortran","text":"Functions to build a TOML data structures The build module defines a high level interface to work with TOML data structures\n and construct them in a convenient way. Uses tomlf_build_array tomlf_build_keyval tomlf_build_merge tomlf_build_table Contents None","tags":"","loc":"module/tomlf_build.html"},{"title":"tomlf_type – TOML-Fortran","text":"Collection of the central datatypes to define TOML data structures All TOML data types should inherit from an abstract value allowing to generate\n a generic interface to deal with all more specialized TOML data types, while\n the abstract value is interesting for developing algorithms in TOML-Fortran,\n the user of TOML-Fortran will usually only care about TOML tables and possibly\n arrays. The TOML types defined here should implement the TOML data structures (mostly)\n without taking the actual implementation of the data structures into account.\n This is done by providing a bare minimum interface using type bound procedures\n to minimize the interdependencies between the datatypes. To make the data types extendable a visitor pattern allows access to the TOML\n data types and can be used to implement further algorithms. Uses tomlf_constants tomlf_error tomlf_type_array tomlf_type_keyval tomlf_type_table tomlf_type_value Contents Interfaces add_array add_keyval add_table Functions is_array_of_tables Interfaces public interface add_array Interface to build new arrays private subroutine add_array_to_table(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private subroutine add_array_to_array(array, ptr, stat) Create a new TOML array inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation public interface add_keyval Interface to build new key-value pairs private subroutine add_keyval_to_table(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private subroutine add_keyval_to_array(array, ptr, stat) Create a new key-value pair inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation public interface add_table Interface to build new tables private subroutine add_table_to_table(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private subroutine add_table_to_array(array, ptr, stat) Create a new TOML table inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation Functions public function is_array_of_tables (array) result(only_tables) Determine if array contains only tables Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array TOML value to visit Return Value logical Array contains only tables","tags":"","loc":"module/tomlf_type.html"},{"title":"tomlf_utils – TOML-Fortran","text":"Uses tomlf_constants tomlf_datetime tomlf_utils_convert tomlf_utils_verify Contents Functions toml_get_value_type Subroutines toml_escape_string Functions public function toml_get_value_type (raw) result(vtype) Determine TOML value type Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw representation of TOML string Return Value integer Value type Subroutines public subroutine toml_escape_string (raw, escaped) Escape all special characters in a TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw representation of TOML string character(kind=tfc,len=:), intent(out), allocatable :: escaped Escaped view of the TOML string","tags":"","loc":"module/tomlf_utils.html"},{"title":"tomlf_de – TOML-Fortran","text":"Uses tomlf_constants tomlf_de_character tomlf_error tomlf_type Contents Interfaces toml_parse Interfaces public interface toml_parse private subroutine toml_parse_unit(table, unit, error) Parse a TOML input from a given IO unit. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table integer, intent(in) :: unit type( toml_error ), intent(out), optional allocatable :: error private subroutine toml_parse_string(table, conf, error) Wrapper to parse a TOML string.\n connect deserializer to configuration Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table character(len=*), intent(in), target :: conf type( toml_error ), intent(out), optional allocatable :: error","tags":"","loc":"module/tomlf_de.html"},{"title":"tomlf_error – TOML-Fortran","text":"Central registry for error codes Uses tomlf_constants Contents Variables toml_stat Derived Types toml_context toml_error Subroutines duplicate_key_error io_error syntax_error vendor_error Variables Type Visibility Attributes Name Initial type(enum_stat), public, parameter :: toml_stat = enum_stat() Actual enumerator for return states Derived Types type, public :: toml_context Context for error message (usually a line in a TOML document) Components Type Visibility Attributes Name Initial integer, public :: num = 0 Current internal count integer, public :: pos = 0 Current internal position character(kind=tfc,len=:), public, pointer :: ptr => null() Current internal location on the string buffer type, public :: toml_error Error message produced by TOML-Fortran Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: message Payload of the error integer, public :: stat = toml_stat%fatal Error code Subroutines public subroutine duplicate_key_error (error, context, key, stat) Key is present multiple times in a TOML document within the same table Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: key The offending duplicate key integer, intent(in), optional :: stat Overwrite of the error code public subroutine io_error (error, message) IO runtime error Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice public subroutine syntax_error (error, context, message, stat) A syntactic error in a TOML document was found Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code public subroutine vendor_error (error, context, message, stat) A shortcoming in the implementation or an internal error occured, rather Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Instance of the TOML error type( toml_context ), intent(in), optional :: context Current context producing the error character(kind=tfc,len=*), intent(in), optional :: message A detailed message describing the error and (optionally) offering advice integer, intent(in), optional :: stat Overwrite of the error code","tags":"","loc":"module/tomlf_error.html"},{"title":"tomlf_ser – TOML-Fortran","text":"TOML serializer implementation Uses tomlf_constants tomlf_type Contents Interfaces new toml_serializer Derived Types toml_serializer Subroutines new_serializer Interfaces public interface new Overloaded constructor for TOML serializers public subroutine new_serializer (self, unit) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer integer, intent(in), optional :: unit Unit for IO public interface toml_serializer Create standard constructor private function new_serializer_func(unit) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: unit Unit for IO Return Value type( toml_serializer ) Instance of the TOML serializer Derived Types type, public, extends( toml_visitor ) :: toml_serializer TOML serializer to produduce a TOML document from a datastructure Components Type Visibility Attributes Name Initial integer, public :: unit = tfout Unit for output Constructor Create standard constructor private  function new_serializer_func (unit) Default constructor for TOML serializer Type-Bound Procedures procedure, public :: visit Visit a TOML value Subroutines public subroutine new_serializer (self, unit) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer integer, intent(in), optional :: unit Unit for IO","tags":"","loc":"module/tomlf_ser.html"},{"title":"tomlf_structure – TOML-Fortran","text":"Abstraction layer for the actual storage of the data structure. The structure implementations provide the actual storage for TOML values, with\n a generic enough interface to make the definition of the TOML data structures\n independent of the actual algorithm used for storing the TOML values. Every data structure defined here should strive to only use allocatable\n data types and limit the use of pointer attributes as they interfer with\n the automatic memory management of Fortran. A well defined data structure\n in allocatables allows deep-copying of TOML values by assignment, data structures\n requiring pointer attributes have to define an assignment(=) interface to\n allow deep-copying of TOML values. Uses tomlf_structure_base tomlf_structure_vector Contents Interfaces len Subroutines new_ordered new_structure Interfaces public interface len Overload len function private pure function get_len(self) result(length) Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(in) :: self Instance of the structure Return Value integer Current length of the ordered structure Subroutines public subroutine new_ordered (self) Constructor for the ordered storage data structure Arguments Type Intent Optional Attributes Name class( toml_ordered ), intent(out), allocatable :: self Instance of the structure public subroutine new_structure (self) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name class( toml_structure ), intent(out), allocatable :: self Instance of the structure","tags":"","loc":"module/tomlf_structure.html"},{"title":"tomlf_version – TOML-Fortran","text":"Version information on TOML-Fortran Contents Variables tomlf_version_compact tomlf_version_string Subroutines get_tomlf_version Variables Type Visibility Attributes Name Initial integer, public, parameter :: tomlf_version_compact = tomlf_major*10000+tomlf_minor*100+tomlf_patch Compact numeric representation of the TOML-Fortran version character(len=*), public, parameter :: tomlf_version_string = \"0.2.1\" String representation of the TOML-Fortran version Subroutines public subroutine get_tomlf_version (major, minor, patch, string) Getter function to retrieve TOML-Fortran version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the TOML-Fortran version integer, intent(out), optional :: minor Minor version number of the TOML-Fortran version integer, intent(out), optional :: patch Patch version number of the TOML-Fortran version character(len=:), intent(out), optional allocatable :: string String representation of the TOML-Fortran version","tags":"","loc":"module/tomlf_version.html"},{"title":"tomlf_build_table – TOML-Fortran","text":"Functions to build TOML tables The build module defines a high level interface to work with TOML tables\n and construct them in a convenient way. The getter functions allow to both retrieve and set values, to easily\n support default values when reading from a TOML data structure.\n Using the getter function with a default value specified will request\n the respective setter function to add it to the table if it was not\n found in the first place. This allows to build a TOML table using only the getter functions, which\n represents the finally read values for the applications. Note that neither setter nor getter functions can overwrite existing\n TOML values for safety reasons, request the deletion on the respective\n key from the TOML table and than set it. The deletion of a subtable or\n array will recursively destroy the contained data nodes. Uses tomlf_build_keyval tomlf_constants tomlf_error tomlf_type Contents Interfaces get_value set_value Interfaces public interface get_value Getter functions to manipulate TOML tables private subroutine get_child_table(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_array(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_keyval(table, key, ptr, requested, stat) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_float_sp(table, key, val, default, stat) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_float_dp(table, key, val, default, stat) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i1(table, key, val, default, stat) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i2(table, key, val, default, stat) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i4(table, key, val, default, stat) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_integer_i8(table, key, val, default, stat) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_bool(table, key, val, default, stat) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation private subroutine get_child_value_string(table, key, val, default, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table character(kind=tfc,len=:), intent(out), allocatable :: val String value character(kind=tfc,len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation public interface set_value Setter functions to manipulate TOML tables private subroutine set_child_value_float_sp(table, key, val, stat) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_float_dp(table, key, val, stat) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i1(table, key, val, stat) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i2(table, key, val, stat) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i4(table, key, val, stat) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_integer_i8(table, key, val, stat) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_bool(table, key, val, stat) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine set_child_value_string(table, key, val, stat) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc,len=*), intent(in) :: key Key in this TOML table character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"module/tomlf_build_table.html"},{"title":"tomlf_build_array – TOML-Fortran","text":"Functions to build TOML arrays. This build module defines a high level interface to work with TOML arrays\n and construct them in a convenient way. The access to the array elements happens by position in the array, the indexing\n is one based, following the language convention of Fortran. All functions\n will only allow access of elements within the bounds of the array, specifying\n indices out-of-bounds should be save, as it only sets the status of operation.\n The getter functions allow access to other tables and arrays as well as\n convenient wrappers to retrieve value data The setter functions are somewhat weaker compared to the setter functions\n available for TOML tables. To limit the potential havoc this routines can\n cause they can only access the array within its bounds. Setting a value to\n another value will overwrite it, while setting a value to a table or an array\n will fail, for safety reasons. To (re)build an array appending to it is the best choice, tables and arrays\n should always be create by using the corresponding add_table and add_array function. While this can become cumbersome for values, the setter routines\n allow out-of-bound access to for the next element in an array and will indeed\n just append a new value to it. Uses tomlf_build_keyval tomlf_constants tomlf_error tomlf_type tomlf_utils Contents Interfaces get_value set_value Interfaces public interface get_value Getter functions to manipulate TOML arrays private subroutine get_elem_table(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_table ), intent(out), pointer :: ptr Pointer to child table integer, intent(out), optional :: stat Status of operation private subroutine get_elem_array(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_array ), intent(out), pointer :: ptr Pointer to child array integer, intent(out), optional :: stat Status of operation private subroutine get_elem_keyval(array, pos, ptr, stat) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_string(array, pos, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc,len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_float_sp(array, pos, val, stat) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_float_dp(array, pos, val, stat) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i1(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i2(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i4(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_int_i8(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_elem_value_bool(array, pos, val, stat) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation public interface set_value Setter functions to manipulate TOML arrays private subroutine set_elem_value_string(array, pos, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_float_sp(array, pos, val, stat) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_float_dp(array, pos, val, stat) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i1(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i2(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i4(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_int_i8(array, pos, val, stat) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_elem_value_bool(array, pos, val, stat) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"module/tomlf_build_array.html"},{"title":"tomlf_build_keyval – TOML-Fortran","text":"Functions to build a TOML values The build module defines an interface to work with TOML values instead\n of accessing the raw value directly. Both setter and getter routines defined\n here are rarely needed in any user context, but serve as a basic building\n block to define uniform access methods for TOML tables and arrays. Uses tomlf_constants tomlf_error tomlf_type tomlf_utils Contents Interfaces get_value set_value Interfaces public interface get_value Getter functions to manipulate TOML values private subroutine get_value_float_sp(self, val, stat) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_sp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine get_value_float_dp(self, val, stat) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_dp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i1(self, val, stat) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i2(self, val, stat) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i4(self, val, stat) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_integer_i8(self, val, stat) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine get_value_bool(self, val, stat) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair logical, intent(out) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine get_value_string(self, val, stat) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair character(kind=tfc,len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation public interface set_value Setter functions to manipulate TOML values private subroutine set_value_float_sp(self, val, stat) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_value_float_dp(self, val, stat) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i1(self, val, stat) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i2(self, val, stat) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i4(self, val, stat) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_integer_i8(self, val, stat) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation private subroutine set_value_bool(self, val, stat) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation private subroutine set_value_string(self, val, stat) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair character(kind=tfc,len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation","tags":"","loc":"module/tomlf_build_keyval.html"},{"title":"tomlf_build_merge – TOML-Fortran","text":"Merge TOML data structures. Merge policy:\n - copy key-value pair in case it is not present in table\n - copy subtable in case it is not present in table\n - copy array in case it is not present in table\n - merge subtable in case it is present in table\n - append array in case it is present in table Uses tomlf_constants tomlf_type Contents Subroutines merge_array merge_table Subroutines public recursive subroutine merge_array (lhs, rhs) Append values from one TOML array to another Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: lhs Instance of array to merge into class( toml_array ), intent(inout) :: rhs Instance of array to be merged public recursive subroutine merge_table (lhs, rhs) Merge TOML tables by appending their values Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: lhs Instance of table to merge into class( toml_table ), intent(inout) :: rhs Instance of table to be merged","tags":"","loc":"module/tomlf_build_merge.html"},{"title":"tomlf_structure_base – TOML-Fortran","text":"Abstract base class definitions for data structures to store TOML values Uses tomlf_constants tomlf_type_value Contents Derived Types toml_ordered toml_structure Derived Types type, public, abstract, extends( toml_structure ) :: toml_ordered Ordered data structure, allows iterations Type-Bound Procedures procedure(delete), public :: delete Delete TOML value at a given key procedure(destroy), public :: destroy Destroy the data structure procedure(find), public :: find Find a TOML value based on its key procedure(get), public :: get Get TOML value at a given index procedure(get_keys), public :: get_keys Get list of all keys in the structure procedure(get_len), public :: get_len Get number of TOML values in the structure procedure(pop), public :: pop Remove the last element from the structure procedure(push_back), public :: push_back Push back a TOML value to the structure procedure(shift), public :: shift Remove the first element from the structure type, public, abstract :: toml_structure Abstract data structure Type-Bound Procedures procedure(delete), public :: delete Delete TOML value at a given key procedure(destroy), public :: destroy Destroy the data structure procedure(find), public :: find Find a TOML value based on its key procedure(get_keys), public :: get_keys Get list of all keys in the structure procedure(push_back), public :: push_back Push back a TOML value to the structure","tags":"","loc":"module/tomlf_structure_base.html"},{"title":"tomlf_structure_vector – TOML-Fortran","text":"Implementation of a basic storage structure as pointer list of pointers. This implementation does purposely not use pointer attributes in the\n datastructure to make it safer to work with. Uses tomlf_constants tomlf_structure_base tomlf_type_value Contents Derived Types toml_vector Subroutines new_vector Derived Types type, public, extends( toml_ordered ) :: toml_vector Stores TOML values in a list of pointers Components Type Visibility Attributes Name Initial type(toml_node), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: delete Delete TOML value at a given key procedure, public :: destroy Destroy the data structure procedure, public :: find Find a TOML value based on its key procedure, public :: get Get TOML value at a given index procedure, public :: get_keys Get list of all keys in the structure procedure, public :: get_len Get number of TOML values in the structure procedure, public :: pop Remove the last element from the structure procedure, public :: push_back Push back a TOML value to the structure procedure, public :: shift Remove the first element from the structure Subroutines public subroutine new_vector (self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_vector ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity","tags":"","loc":"module/tomlf_structure_vector.html"},{"title":"tomlf_utils_verify – TOML-Fortran","text":"Contains utilities to verify TOML raw values correspond to a certain datatype Uses tomlf_constants Contents Functions toml_raw_verify_bool toml_raw_verify_date toml_raw_verify_float toml_raw_verify_integer toml_raw_verify_string toml_raw_verify_time toml_raw_verify_timestamp Functions public pure function toml_raw_verify_bool (raw) result(stat) Verify a raw value as TOML bool Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_date (raw) result(stat) Verify a raw value as TOML date expression (YYYY-MM-DD) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_float (raw) result(stat) Verify a raw value as TOML float Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_integer (raw) result(stat) Verify a raw value as TOML integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_string (raw) result(stat) Verify a raw value as TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_time (raw) result(stat) Verify a raw value as TOML time expression (HH:MM:SS) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation public pure function toml_raw_verify_timestamp (raw) result(stat) Verify a raw value as TOML datetime expression Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to verify Return Value logical Status of the evaluation","tags":"","loc":"module/tomlf_utils_verify.html"},{"title":"tomlf_utils_convert – TOML-Fortran","text":"Contains utilities to convert TOML raw values to actual Fortran datatypes Uses tomlf_constants tomlf_datetime tomlf_utils_verify Contents Interfaces convert_raw Functions toml_raw_to_bool toml_raw_to_float toml_raw_to_integer toml_raw_to_string toml_raw_to_timestamp Interfaces public interface convert_raw Overloaded conversion interface public function toml_raw_to_string (raw, str) result(stat) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw character(kind=tfc,len=:), intent(out), allocatable :: str Return Value logical public function toml_raw_to_float (raw, num) result(stat) Attempt to convert TOML raw value to Fortran real Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert real(kind=tfr), intent(out) :: num Real value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_bool (raw, bool) result(stat) Attempt to convert TOML raw value to Fortran logical Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert logical, intent(out) :: bool Logical value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_integer (raw, num) result(stat) Attempt to convert TOML raw value to Fortran integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert integer(kind=tfi), intent(out) :: num Integer value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_timestamp (raw, timestamp) result(stat) Attempt to convert TOML raw value to TOML datetime Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert type( toml_datetime ), intent(out) :: timestamp TOML datetime value Return Value logical Status of the evaluation Functions public function toml_raw_to_bool (raw, bool) result(stat) Attempt to convert TOML raw value to Fortran logical Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert logical, intent(out) :: bool Logical value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_float (raw, num) result(stat) Attempt to convert TOML raw value to Fortran real Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert real(kind=tfr), intent(out) :: num Real value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_integer (raw, num) result(stat) Attempt to convert TOML raw value to Fortran integer Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert integer(kind=tfi), intent(out) :: num Integer value represented by raw value Return Value logical Status of the evaluation public function toml_raw_to_string (raw, str) result(stat) Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw character(kind=tfc,len=:), intent(out), allocatable :: str Return Value logical public function toml_raw_to_timestamp (raw, timestamp) result(stat) Attempt to convert TOML raw value to TOML datetime Arguments Type Intent Optional Attributes Name character(kind=tfc,len=*), intent(in) :: raw Raw value to convert type( toml_datetime ), intent(out) :: timestamp TOML datetime value Return Value logical Status of the evaluation","tags":"","loc":"module/tomlf_utils_convert.html"},{"title":"tomlf_type_value – TOML-Fortran","text":"Class definitions for basic data types used for handling TOML Uses tomlf_constants tomlf_utils Contents Derived Types toml_key toml_value toml_visitor Derived Types type, public :: toml_key Thin wrapper around the deferred-size character intrinisc Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value type, public, abstract :: toml_value Abstract base value for TOML data types Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure(destroy), public :: destroy Release allocation hold by TOML value procedure, public :: get_key Get escaped key to TOML value procedure, public :: match_key Compare raw key of TOML value to input key type, public, abstract :: toml_visitor Abstract visitor for TOML values Type-Bound Procedures procedure(visit), public :: visit Visitor visiting a TOML value","tags":"","loc":"module/tomlf_type_value.html"},{"title":"tomlf_type_table – TOML-Fortran","text":"Implementation of the TOML table data type. Every TOML document contains at least one (root) table which holds key-value\n pairs, arrays and other tables. Uses tomlf_constants tomlf_error tomlf_type_value tomlf_structure Contents Interfaces new toml_table Derived Types toml_table Subroutines new_table Interfaces public interface new Overloaded constructor for TOML values public subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table public interface toml_table Create standard constructor private function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table Derived Types type, public, extends( toml_value ) :: toml_table TOML table Components Type Visibility Attributes Name Initial logical, public :: implicit = .false. Table was implictly created logical, public :: inline = .false. Is an inline table and is therefore non-extendable character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value class( toml_structure ), public, allocatable :: list Storage unit for TOML values of this table Constructor Create standard constructor private  function new_table_func () Default constructor for TOML table type Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: delete Delete TOML value at a given key procedure, public :: destroy Release allocation hold by TOML table procedure, public :: get Get the TOML value associated with the respective key procedure, public :: get_key Get escaped key to TOML value procedure, public :: get_keys Get list of all keys in this table procedure, public :: has_key Check if key is already present in this table instance procedure, public :: match_key Compare raw key of TOML value to input key procedure, public :: push_back Append value to table (checks automatically for key) Subroutines public subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table","tags":"","loc":"module/tomlf_type_table.html"},{"title":"tomlf_type_array – TOML-Fortran","text":"Implementation of the TOML array data type. Uses tomlf_error tomlf_type_value tomlf_structure Contents Interfaces len new toml_array Derived Types toml_array Subroutines new_array Interfaces public interface len Overload len function private pure function get_len(self) result(length) Get number of TOML values in the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(in) :: self Instance of the TOML array Return Value integer Current length of the array public interface new Overloaded constructor for TOML values public subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array public interface toml_array Create standard constructor private function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array Derived Types type, public, extends( toml_value ) :: toml_array TOML array Components Type Visibility Attributes Name Initial logical, public :: inline = .true. Is an inline array rather than an array of tables character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value class( toml_ordered ), public, allocatable :: list Storage unit for TOML values of this array Constructor Create standard constructor private  function new_array_func () Default constructor for TOML array type Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: destroy Release allocation hold by TOML array procedure, public :: get Get the TOML value at a given index procedure, public :: get_key Get escaped key to TOML value procedure, public :: match_key Compare raw key of TOML value to input key procedure, public :: pop Remove the last element from the array procedure, public :: push_back Append value to array procedure, public :: shift Remove the first element from the array Subroutines public subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array","tags":"","loc":"module/tomlf_type_array.html"},{"title":"tomlf_type_keyval – TOML-Fortran","text":"TOML key-value pair Uses tomlf_constants tomlf_type_value Contents Interfaces new Derived Types toml_keyval Subroutines new_keyval Interfaces public interface new Overloaded constructor for TOML values public subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair Derived Types type, public, extends( toml_value ) :: toml_keyval TOML key-value pair Components Type Visibility Attributes Name Initial character(kind=tfc,len=:), public, allocatable :: key Raw representation of the key to the TOML value character(kind=tfc,len=:), public, allocatable :: raw Raw content of the TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: destroy Release allocation hold by TOML key-value pair procedure, public :: get_key Get escaped key to TOML value procedure, public :: match_key Compare raw key of TOML value to input key Subroutines public subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair","tags":"","loc":"module/tomlf_type_keyval.html"},{"title":"tomlf_de_tokenizer – TOML-Fortran","text":"Definition of the TOML tokens and the possible states of the tokenizer The tokenizer implementation has to produce tokens from any input source\n and is usually only required for string tokens to provide an actual character\n representation. The tokenization is partly dependent on the context, as the dot is not in\n all states actually a token, also due to the rather complex syntax of\n table headers, whitespace is precious and has to be reported as token. Not required but usually helpful is the creation of a context, usually\n represented by the current line (or a chunk of lines for multiline strings),\n which can be passed to the error handler to create more detailed output.\n A tokenizer working with the complete TOML document as character sequence\n can easily create the context, while it might be incomplete or missing in\n case of a stream processing. Uses tomlf_constants tomlf_error tomlf_utils tomlf_type Contents Variables toml_tokentype Derived Types toml_token toml_tokenizer Variables Type Visibility Attributes Name Initial type(enum_tokentype), public, parameter :: toml_tokentype = enum_tokentype() Derived Types type, public :: toml_token Basic TOML token, produced by a TOML tokenizer Components Type Visibility Attributes Name Initial integer, public :: len = 0 Length of the token at ptr character(len=:), public, pointer :: ptr => null() Character representation of the token integer, public :: tok = toml_tokentype%invalid Actual tokentype type, public, abstract :: toml_tokenizer Abstract TOML tokenizer Components Type Visibility Attributes Name Initial type( toml_table ), public, pointer :: current => null() Pointer to the current table while transversing a table path type( toml_error ), public, allocatable :: error Error buffer, if allocated an error has occurred logical, public :: finished = .false. Signals if the tokenizer has finished (EOF has been reached) type( toml_context ), public :: line Current line (for error handling) type( toml_table ), public, allocatable :: root Root table type( toml_token ), public :: tok Current token Type-Bound Procedures procedure(next_token), public :: next_token Return next token procedure, public :: parse => parse_root Entry point for parsing the TOML document, creates the root table","tags":"","loc":"module/tomlf_de_tokenizer.html"},{"title":"tomlf_de_character – TOML-Fortran","text":"Implementation of a tokenizer for character variables Uses tomlf_constants tomlf_error tomlf_de_tokenizer tomlf_utils Contents Interfaces new Derived Types toml_character_tokenizer Subroutines new_character_tokenizer Interfaces public interface new public subroutine new_character_tokenizer (de, conf) Constructor for the deserializer implementation.\n connect deserializer to configuration\n first token is an artifical newline Arguments Type Intent Optional Attributes Name type( toml_character_tokenizer ), intent(out) :: de character(len=*), intent(in), target :: conf Derived Types type, public, extends( toml_tokenizer ) :: toml_character_tokenizer Tokenizer for a sequence of characters Components Type Visibility Attributes Name Initial character(len=:), public, pointer :: conf Link to the input configuration. type( toml_table ), public, pointer :: current => null() Pointer to the current table while transversing a table path type( toml_error ), public, allocatable :: error Error buffer, if allocated an error has occurred logical, public :: finished = .false. Signals if the tokenizer has finished (EOF has been reached) type( toml_context ), public :: line Current line (for error handling) type( toml_table ), public, allocatable :: root Root table type( toml_token ), public :: tok Current token Type-Bound Procedures procedure, public :: next_token Return next token procedure, public :: parse => parse_root Entry point for parsing the TOML document, creates the root table Subroutines public subroutine new_character_tokenizer (de, conf) Constructor for the deserializer implementation.\n connect deserializer to configuration\n first token is an artifical newline Arguments Type Intent Optional Attributes Name type( toml_character_tokenizer ), intent(out) :: de character(len=*), intent(in), target :: conf","tags":"","loc":"module/tomlf_de_character.html"}]}